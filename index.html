<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1, viewport-fit=cover" name="viewport"/>
<title>Money Forecast App</title>
<script src="https://cdn.tailwindcss.com">
// Sync dashboard forecast toggle state after all functions are defined
window.addEventListener('load', function(){
  try{
    if (typeof setForecastView === 'function'){
      setForecastView(window._mm_forecastView || 'month');
    }
  }catch(e){}
});

</script>
<script>
/* ===== Debt Planner Safe Extra ===== */
function calculateSafeExtra() {
  if (!_mm_getMultiMonthData().length || Object.keys(_mm_getDailyBalances()).length===0) { return 0; }
  return _origCalculateSafeExtra();
};

// Recalculate Safe Extra whenever forecast recalculates
(function hookForecastRefresh(){
  const _calc = window.calculateForecast;
  if (typeof _calc !== 'function') return;

  window.calculateForecast = function () {
    const result = _calc.apply(this, arguments);
    setTimeout(() => {
      if (typeof refreshSafeExtraUI === 'function') {
        refreshSafeExtraUI();
      }
    }, 50);
    return result;
  };
})();

/* ===== FIX: access top-level let vars (not on window) ===== */
function _mm_getDailyBalances(){
  try {
    if (typeof dailyBalances !== 'undefined' && dailyBalances) return dailyBalances;
  } catch(e){}
  return window.dailyBalances || {};
}
function _mm_getMultiMonthData(){
  try {
    if (typeof multiMonthData !== 'undefined' && Array.isArray(multiMonthData)) return multiMonthData;
  } catch(e){}
  return window.multiMonthData || [];
}
function _mm_getDebtPlanPaymentDay(){
  try {
    if (typeof debtPlanPaymentDay !== 'undefined' && debtPlanPaymentDay) return debtPlanPaymentDay;
  } catch(e){}
  return window.debtPlanPaymentDay || 1;
}

// Wrap calculateForecast to publish aliases for inline handlers & helpers
(function _mm_publishForecastGlobals(){
  const _calc = window.calculateForecast;
  if (typeof _calc !== 'function') return;
  if (_calc._mm_wrapped) return;

  function wrappedCalculateForecast(){
    const res = _calc.apply(this, arguments);
    try {
      window.dailyBalances = (typeof dailyBalances !== 'undefined') ? dailyBalances : window.dailyBalances;
      window.multiMonthData = (typeof multiMonthData !== 'undefined') ? multiMonthData : window.multiMonthData;
      window.debtPlanPaymentDay = (typeof debtPlanPaymentDay !== 'undefined') ? debtPlanPaymentDay : window.debtPlanPaymentDay;
    } catch(e){}
    return res;
  }
  wrappedCalculateForecast._mm_wrapped = true;
  window.calculateForecast = wrappedCalculateForecast;
})();

</script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
  /* ==============================
     Money Map – Pro “Bank / Fintech” Theme
     (Overrides Tailwind utility colors so we can keep your HTML intact)
     ============================== */
  :root{
    --mm-bg: #f5f7fb;
    --mm-surface: #ffffff;
    --mm-border: #e5e7eb;
    --mm-text: #0f172a;
    --mm-muted: #64748b;
    --mm-primary: #1d4ed8;     /* blue-700 */
    --mm-primary-800: #1e40af; /* blue-800 */
    --mm-nav: #0b1220;         /* deep navy */
    --mm-nav-2: #111827;       /* slate-900 */
    --mm-accent: #fbbf24;      /* amber-400 */
  }

  html, body { -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
  body{ background: var(--mm-bg) !important; color: var(--mm-text); }

  /* Background utility overrides */
  .bg-gray-100{ background-color: var(--mm-bg) !important; }
  .bg-green-700{ background-color: var(--mm-nav) !important; }
  .bg-green-800{ background-color: var(--mm-nav-2) !important; }
  .bg-green-600{ background-color: var(--mm-primary) !important; }
  .bg-green-500{ background-color: var(--mm-primary) !important; }
  .bg-blue-600{ background-color: var(--mm-primary) !important; }
  .bg-blue-700{ background-color: var(--mm-primary-800) !important; }

  /* Border utility overrides used by the sidebar */
  .border-green-700{ border-color: rgba(255,255,255,0.10) !important; }

  /* Hover/active utility overrides for the side menu buttons */
  .hover\:bg-green-700:hover{ background-color: rgba(255,255,255,0.08) !important; }
  .active\:bg-green-600:active{ background-color: rgba(255,255,255,0.12) !important; }

  /* Text utility overrides */
  .text-yellow-300{ color: var(--mm-accent) !important; }

  /* Cards: reduce “web shadow”, add subtle border like real finance apps */
  .shadow{ box-shadow: 0 1px 2px rgba(15,23,42,0.06), 0 1px 1px rgba(15,23,42,0.04) !important; }
  .shadow-lg{ box-shadow: 0 10px 25px rgba(15,23,42,0.10) !important; }
  .bg-white{ background-color: var(--mm-surface) !important; }
  .rounded-xl{ border-radius: 16px !important; }
  .rounded-lg{ border-radius: 14px !important; }

  /* Give common “card” containers a border without editing every div */
  .bg-white.shadow{ border: 1px solid var(--mm-border) !important; }

  /* Inputs / selects: slightly more premium */
  input, select, textarea{
    border-color: #cbd5e1;
  }
  input:focus, select:focus, textarea:focus{
    outline: none;
    border-color: rgba(29,78,216,0.55);
    box-shadow: 0 0 0 3px rgba(29,78,216,0.15);
  }

  .mm-disabled { background:#eee !important; color:#666 !important; }

  /* Mobile fit helpers */
  html, body {
    width: 100%;
    max-width: 100%;
    overflow-x: hidden;
  }
  *, *::before, *::after {
    box-sizing: border-box;
  }
  /* Prevent flex children from causing overflow */
  .mm-min-w-0 { min-width: 0; }
  /* Make canvases behave on small screens (JS may still set an explicit width for scroll charts) */
  canvas {
    max-width: 100%;
  }

  
/* Bills pie: keep perfectly circular inside its square wrapper */
#billsPieChart{width:100% !important;height:100% !important;}
/* IMPORTANT: the Daily Forecast chart intentionally uses a wide canvas + horizontal scrolling.
     Prevent the global canvas max-width rule from squishing it on mobile. */
  #dailyForecastScroll{ overflow-x: auto; -webkit-overflow-scrolling: touch; }
  #dailyForecastCanvas{ max-width: none !important; display: block; }


  input:disabled, select:disabled, textarea:disabled { opacity: 0.55; cursor: not-allowed; }

  @keyframes mmFadeIn {
    from { opacity: 0; transform: translateY(4px); }
    to   { opacity: 1; transform: translateY(0); }
  }
  .mm-fade-in { animation: mmFadeIn .18s ease-out both; }

/* Debt Plan Preview Table */
#debtPlanPreviewModal table { table-layout: fixed; width: 100%; }
#debtPlanPreviewModal th, #debtPlanPreviewModal td { vertical-align: middle; }
#debtPlanPreviewModal th { white-space: normal; }



    /* Daily Forecast (continuous scroll) */
  #dailyForecastScroll{ -webkit-overflow-scrolling: touch; }
  #dailyForecastCanvas{ height:180px !important; }


  .side-link.active{
    background-color: rgba(255,255,255,0.12);
    font-weight: 600;
  }
</style>
</head>
<body class="bg-gray-100 overflow-x-hidden">
<div class="flex h-screen">
<!-- Side Menu -->
<div class="fixed inset-y-0 left-0 w-64 bg-green-800 text-white shadow transform -translate-x-full transition-transform duration-300 z-50" id="sideMenu">
<h2 class="font-bold text-xl p-4 border-b border-green-700 text-white">Menu</h2>
<ul class="p-4 space-y-2">
<li><button class="side-link w-full text-left px-3 py-2 rounded-md hover:bg-green-700 active:bg-green-600 transition" data-tab="dashboard" onclick="showTab('dashboard'); toggleMenu()">Dashboard</button></li>
<li><button class="side-link w-full text-left px-3 py-2 rounded-md hover:bg-green-700 active:bg-green-600 transition" data-tab="accountsTab" onclick="showTab('accountsTab'); toggleMenu()">Accounts</button></li>
<li><button class="side-link w-full text-left px-3 py-2 rounded-md hover:bg-green-700 active:bg-green-600 transition" data-tab="incomeTab" onclick="showTab('incomeTab'); toggleMenu()">Income</button></li>
<li><button class="side-link w-full text-left px-3 py-2 rounded-md hover:bg-green-700 active:bg-green-600 transition" data-tab="billsTab" onclick="showTab('billsTab'); toggleMenu()">Bills</button></li>
<li><button class="side-link w-full text-left px-3 py-2 rounded-md hover:bg-green-700 active:bg-green-600 transition" data-tab="calendarTab" onclick="showTab('calendarTab'); toggleMenu()">Calendar</button></li>
<li><button class="side-link w-full text-left px-3 py-2 rounded-md hover:bg-green-700 active:bg-green-600 transition" data-tab="multiMonthTab" onclick="showTab('multiMonthTab'); toggleMenu()">Multi-Month</button></li>
<li><button class="side-link w-full text-left px-3 py-2 rounded-md hover:bg-green-700 active:bg-green-600 transition" data-tab="debtPlannerTab" onclick="showTab('debtPlannerTab'); toggleMenu()">Debt Planner</button></li>
<li><button class="side-link w-full text-left px-3 py-2 rounded-md text-white hover:bg-green-700 active:bg-green-600 transition" data-tab="backupTab" onclick="showTab('backupTab'); toggleMenu()">Backup</button></li>
</ul>
</div>
<div class="hidden fixed inset-0 bg-black/30 z-40" id="menuBackdrop" onclick="toggleMenu(true)"></div>
<!-- Main Content -->
<div class="flex-1 relative mx-auto w-full max-w-[430px] sm:max-w-none mm-min-w-0">
<!-- Top Bar -->
<div class="flex items-center p-4 bg-green-800 text-white shadow">
<button class="p-2 rounded-full bg-green-700 mr-4" onclick="toggleMenu()">
<svg class="h-6 w-6" fill="none" stroke="currentColor" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<path d="M4 6h16M4 12h16M4 18h16" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path>
</svg>
</button>
<div class="ml-3 flex items-center gap-2">
<span class="text-sm opacity-90">Profile</span>
<select class="text-sm px-2 py-1 rounded-md text-gray-900" id="profileSelect" onchange="switchProfile(this.value)"></select>
<button class="text-sm px-2 py-1 bg-green-800 rounded-md" onclick="openProfileModal()">Manage</button>
</div>
</div>
<!-- Dashboard -->
<div class="p-4" id="dashboard">
<div class="mb-4 bg-white rounded-xl shadow p-4">
<div class="flex items-center justify-between gap-3">
<div>
<div class="text-sm text-gray-500">Daily Forecast</div>
<div class="text-xs text-gray-400">Forecasted balance by day (scroll to see future months)</div>
</div>
<div class="flex items-center gap-2">
  <div class="inline-flex rounded-lg border bg-white overflow-hidden text-xs">
    <button id="forecastViewDay" class="px-3 py-1.5" onclick="setForecastView('day')">Day</button>
    <button id="forecastViewMonth" class="px-3 py-1.5" onclick="setForecastView('month')">Month</button>
    <button id="forecastViewYear" class="px-3 py-1.5" onclick="setForecastView('year')">Year</button>
  </div>
  <div id="forecastScrollHint" class="text-xs text-gray-400 whitespace-nowrap">Scroll →</div>
</div>
</div>
<div class="mt-3 overflow-x-auto pb-2" id="dailyForecastScroll">
<canvas height="180" id="dailyForecastCanvas"></canvas>
</div>
</div>

<div class="mb-4 grid grid-cols-1 sm:grid-cols-3 gap-3">
<div class="bg-white rounded-xl shadow p-4">
<div class="text-sm text-gray-500">Today's Forecasted Balance</div>
<div class="text-2xl font-bold" id="todayForecastBalance">$0.00</div>
<div class="text-xs text-gray-400 mt-1" id="todayForecastDate"></div>
</div>
<div class="bg-white rounded-xl shadow p-4">
<div class="text-sm text-gray-500">12 Month Forecasted Delta</div>
<div class="text-2xl font-bold" id="forecastDelta12mo">$0.00</div>
<div class="text-xs text-gray-400 mt-1">vs today</div>
</div>
<div class="bg-white rounded-xl shadow p-4">
<div class="text-sm text-gray-500">12 Month Forecasted Balance</div>
<div class="text-2xl font-bold" id="forecastBalance12mo">$0.00</div>
<div class="text-xs text-gray-400 mt-1">end of month 12</div>
</div>
</div>
<div class="mb-4 bg-white rounded-xl shadow p-4">
<div class="flex items-start justify-between gap-3">
<div>
<div class="font-bold text-lg">Update Balances</div>
<div class="text-xs text-gray-500">Update your real-world balances first, then tap Calculate Forecast.</div>
</div>
<button class="text-xs px-3 py-2 border rounded-lg" onclick="syncDashboardBalancesFromModals(); navigator.vibrate?.(25);">Refresh</button>
</div>
<div class="mt-2 text-xs text-gray-500" id="dashboardLastUpdated">Last updated: —</div>
<div class="mt-3">
<div class="font-semibold text-sm mb-2">Accounts</div>
<div class="space-y-2" id="dashboardAccountBalances"></div>
<div class="mt-3 flex items-center justify-between">
<div class="text-sm text-gray-600">Total cash (debit accounts)</div>
<div class="text-sm font-semibold" id="dashboardTotalCash">$0.00</div>
</div>
</div>
</div>
<!-- Kept for backwards compatibility (the forecast uses this as "today's cash") -->
<label class="block hidden">Current Balance ($)</label>
<input class="w-full p-2 mb-4 border rounded hidden" id="balance" inputmode="decimal" type="number"/>
<button class="w-full bg-blue-600 text-white p-3 rounded-xl font-semibold" onclick="computeForecast(); navigator.vibrate?.(50);">Calculate Forecast</button>
<div class="mt-3 text-xs text-gray-500">
        Tip: For a bill paid by a credit card, choose <span class="font-semibold">Paid With: Credit Card</span>.
        The bill will impact your forecast on the card’s <span class="font-semibold">due date</span>, not the bill date.
      </div>
</div>
<!-- Income -->
<div class="p-4 hidden" id="incomeTab">
<div class="mb-4 bg-white rounded-xl shadow p-4">
<div class="flex items-center justify-between gap-3">
<div>
<div class="font-bold text-lg">Income</div>
<div class="text-xs text-gray-500">Manage your income sources used in forecasting.</div>
</div>
<button class="text-blue-600 font-semibold text-sm" onclick="addIncome(); navigator.vibrate?.(25);">+ Add Income</button>
</div>
</div>
<div class="space-y-2" id="incomeList"></div>
<div class="mt-3 text-xs text-gray-500">
        Tip: Income is applied on its date in the forecast. Use recurrence for paychecks.
      </div>
</div>
<!-- Accounts -->
<div class="p-4 hidden" id="billsTab">
<div class="mb-4 bg-white rounded-xl shadow p-4">
<div class="flex items-center justify-between gap-3">
<div>
<div class="text-sm text-gray-500">Bills by Category</div>
<div class="text-xs text-gray-400">Select a month to see category percentages</div>
</div>
<select class="p-2 border rounded text-sm" id="billsMonthSelect"></select>
</div>
<div class="mt-3 flex justify-center">
<div style="width:220px; height:220px;">
<canvas id="billsPieChart"></canvas>
</div>
</div>
</div>
<div class="flex items-center justify-between mb-2">
<h2 class="font-semibold">Bills</h2>
<div class="flex items-center gap-3">
<button class="text-gray-700 text-sm border px-3 py-1.5 rounded-lg" onclick="openCategoryModal()">Manage Categories</button>
<button class="text-blue-600" onclick="addExpense()">+ Add Bill</button>
</div>
</div>
<div class="space-y-1" id="billsList"></div>
</div>
<div class="hidden p-4 space-y-4 overflow-auto h-[calc(100vh-64px)]" id="accountsTab">
<div class="bg-white rounded-xl shadow p-4">
<div class="flex items-center justify-between gap-3">
<div>
<div class="font-bold text-lg">Accounts</div>
<div class="text-xs text-gray-500">Add debit/checking and credit card accounts. Credit card due dates drive when CC-paid bills affect the forecast.</div>
</div>
<button class="text-blue-600 font-semibold text-sm" onclick="addAccount(); navigator.vibrate?.(25);">+ Add Account</button>
</div>
</div>
<div class="grid gap-3">
<div class="bg-white rounded-xl shadow p-4">
<div class="font-semibold mb-2">Debit / Checking</div>
<div class="space-y-2" id="debitAccountsList"></div>
</div>
<div class="bg-white rounded-xl shadow p-4">
<div class="font-semibold mb-2">Credit Cards</div>
<div class="space-y-2" id="creditAccountsList"></div>
</div>
</div>
</div>
<!-- Calendar -->
<div class="hidden p-4 space-y-6 overflow-auto h-[calc(100vh-64px)]" id="calendarTab"></div>
<!-- Multi-Month -->
<div class="hidden p-4 overflow-auto" id="multiMonthTab">
<table class="w-full border rounded bg-white text-xs">
<thead class="bg-gray-200">
<tr>
<th class="p-2">Month-Year</th>
<th class="p-2">Income</th>
<th class="p-2">Expenses</th>
<th class="p-2">Ending Balance</th>
</tr>
</thead>
<tbody id="multiMonthBody"></tbody>
</table>
</div>
<!-- Debt Planner -->
<div class="hidden p-4 space-y-4 overflow-auto h-[calc(100vh-64px)]" id="debtPlannerTab">
<!-- Safe Principal Payment -->
<!-- Sweep Mode + Impact + Mini Strip -->
<div class="bg-white rounded-xl shadow p-4 mb-4 border border-blue-200">
<div class="flex items-center justify-between mb-2">
<h3 class="font-semibold text-blue-700">Advanced Paydown Controls</h3>
</div>
<div class="mt-2 flex items-center justify-between bg-white rounded-lg p-3 border border-blue-100">
<div class="pr-3">
<div class="font-semibold text-gray-900">Apply debt payments to forecast/calendar</div>
<div class="text-sm text-gray-600">If off, debt payments won’t be injected into the forecast or calendar.</div>
</div>
<label class="mm-switch">
<input id="applyDebtPlanToggle" type="checkbox"/>
<span class="mm-slider"></span>
</label>
</div>
<!-- Sweep Mode -->
<!-- Payment Day Impact -->
<div class="text-sm text-gray-700 mb-3" id="paymentDayImpact"></div>
<!-- Mini 5-year Balance Strip -->
<div>
<div class="text-xs text-gray-500 mb-1">Lowest projected balance by month</div>
<div class="w-full max-w-full overflow-hidden">
  <div class="w-full max-w-full overflow-x-auto overflow-y-hidden">
    <div class="flex items-end space-x-1 h-12 w-max" id="miniBalanceStrip"></div>
  </div>
</div>
</div>
</div>
<div class="bg-white hidden rounded-xl shadow p-4 mb-4 border border-green-200" data-mm-hidden-apply-settings="">
<div class="flex items-center justify-between mb-2">
<h3 class="font-semibold text-green-700">Safe Principal Payment</h3>
<select class="border rounded px-2 py-1 text-sm" id="debtBufferSelect" onchange="onDebtBufferChange(this.value)">
<option value="0">$0 buffer</option>
<option value="250">$250 buffer</option>
<option value="500">$500 buffer</option>
<option value="1000">$1000 buffer</option>
</select>
</div>
<div class="text-2xl font-bold text-green-800" id="safeExtraValue">$0.00</div>
<div class="text-sm text-gray-600 mt-1">
    Next month safe principal payment after bills &amp; buffer
  </div>
<div class="mt-3 text-sm text-gray-700" id="safeExtraBreakdown"></div>
<button class="mt-3 bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700" onclick="window.applySafeExtra()">
    Use Safe Extra
  </button>
</div>
<!-- Header / CTA -->
<div class="bg-white hidden rounded-xl shadow p-4" data-mm-hidden-global-payday="">
<div class="flex items-start justify-between gap-3">
<div>
<div class="font-bold text-lg">Debt &amp; Loan Payoff Planner</div>
<div class="text-xs text-gray-500">
              Add your debts, pick a payoff strategy, and apply the plan to your cash forecast.
            </div>
</div>
<button class="text-blue-600 font-semibold whitespace-nowrap" onclick="addDebt()">+ Add Debt</button>
</div>
</div>
<!-- Strategy + Payment Settings -->
<div class="bg-white hidden rounded-xl shadow p-4" data-mm-hidden-strategy="">
<div class="font-semibold mb-2">Payoff Strategy</div>
<div class="space-y-2 text-sm">
<label class="flex items-center gap-2 cursor-pointer">
<input checked="" class="accent-blue-600" name="debtStrategy" onchange="renderDebtPlanner()" type="radio" value="avalanche"/>
<div>
<div class="font-medium">Avalanche</div>
<div class="text-xs text-gray-500">Pay highest APR first (usually saves the most interest).</div>
</div>
</label>
<label class="flex items-center gap-2 cursor-pointer">
<input class="accent-blue-600" name="debtStrategy" onchange="renderDebtPlanner()" type="radio" value="snowball"/>
<div>
<div class="font-medium">Snowball</div>
<div class="text-xs text-gray-500">Pay smallest balance first (quick wins).</div>
</div>
</label>
<label class="flex items-center gap-2 cursor-pointer">
<input class="accent-blue-600" name="debtStrategy" onchange="renderDebtPlanner()" type="radio" value="custom"/>
<div>
<div class="font-medium">Custom</div>
<div class="text-xs text-gray-500">Drag debts to set the payoff order.</div>
</div>
</label>
</div>
<!-- Payment settings (applied on button click) -->
<div class="mt-4 grid grid-cols-1 sm:grid-cols-2 gap-3">
<div class="grid gap-1">
<!-- Hidden legacy input (kept for backward compatibility) -->
<input class="hidden" id="extraMonthlyPayment" min="0" step="1" type="number" value="0"/>
</div>
<div class="grid gap-1">
<label class="text-sm font-semibold">Debt plan payment day (1–28)</label>
<input class="w-full p-2 border rounded" id="debtPlanPayDay" max="28" min="1" type="number" value="1"/>
<div class="text-xs text-gray-500">When applied to forecast, the plan schedules the monthly debt payment on this day.</div>
</div>
</div>
<div class="mt-3">
<button class="w-full bg-blue-600 text-white p-2.5 rounded-lg font-semibold" id="applyDebtPlanSettingsBtn" onclick="applyDebtPlanSettings()">
            Apply payment settings
          </button>
<div class="text-xs text-gray-500 mt-1">Tip: After editing these fields, tap Apply to update your plan (per project).</div>
</div>
<div class="mt-4 flex items-center justify-between gap-3 border-t pt-3">
<div>
<div class="text-sm font-semibold">Apply plan to forecast</div>
<div class="text-xs text-gray-500">Adds payoff payments into the cash forecast.</div>
</div>
<label class="mm-switch">
<input class="sr-only" id="applyPlanToForecast" onchange="onApplyPlanToggleChange(this.checked)" type="checkbox"/>
<span class="mm-slider"></span>
</label>
</div>
<div class="hidden mt-3 p-3 rounded-lg border text-sm" id="debtWarnings"></div>
</div>
<!-- Summary cards -->
<div class="grid grid-cols-1 sm:grid-cols-3 gap-3">
<div class="bg-white rounded-xl shadow p-4">
<div class="text-xs text-gray-500">Debt-Free Date</div>
<div class="text-xl font-bold" id="debtFreeDate">—</div>
</div>
<div class="bg-white rounded-xl shadow p-4">
<div class="text-xs text-gray-500">Total Interest</div>
<div class="text-xl font-bold" id="totalInterest">—</div>
</div>
<div class="bg-white rounded-xl shadow p-4">
<div class="text-xs text-gray-500">Months to Payoff</div>
<div class="text-xl font-bold" id="monthsToPayoff">—</div>
</div>
</div>
<!-- Debt list -->
<div class="bg-white rounded-xl shadow p-4">
<div class="flex items-center justify-between">
<div class="font-semibold">Your Debts</div>
<div class="flex items-center gap-2"><button class="text-sm text-blue-600" onclick="renderDebtPlanner()">Refresh</button><button class="text-blue-600 font-semibold text-sm" onclick="addDebt()">+ Add Debt</button></div>
</div>
<div class="mt-3 space-y-2" id="debtList"></div>
<div class="hidden mt-3 text-sm text-gray-500" id="debtEmptyState">
          No debts yet. Tap <span class="font-semibold">+ Add Debt</span> to get started.
        </div>
</div>
<!-- Custom order card -->
<div class="hidden bg-white rounded-xl shadow p-4" id="customOrderCard">
<div class="flex items-center justify-between">
<div>
<div class="font-semibold">Custom Payoff Order</div>
<div class="text-xs text-gray-500">Drag debts to set the order (top = paid first).</div>
</div>
<button class="text-sm text-blue-600" onclick="normalizeDebtOrder(); renderDebtPlanner();">Normalize</button>
</div>
<div class="mt-3 space-y-2" id="customOrderList"></div>
</div>
</div>
<!-- Backup -->
<div class="hidden p-4 space-y-4 overflow-auto h-[calc(100vh-64px)]" id="backupTab">
<div class="bg-white rounded-xl shadow p-4">
<div class="text-xl font-bold mb-1">Backup &amp; Restore</div>
<div class="text-sm text-gray-600">Export a JSON backup of this profile, or import a backup to overwrite the current profile on this device.</div>
</div>
<div class="bg-white rounded-xl shadow p-4 space-y-3">
<div class="flex flex-col sm:flex-row gap-3">
<button class="px-4 py-2 rounded-lg bg-green-700 text-white hover:bg-green-800 transition w-full sm:w-auto" onclick="exportData()" type="button">Export Data</button>
<button class="px-4 py-2 rounded-lg bg-gray-900 text-white hover:bg-black transition w-full sm:w-auto" onclick="document.getElementById('backupImportInput').click()" type="button">Import Data</button>
</div>
<input accept="application/json" class="hidden" id="backupImportInput" onchange="importData(event)" type="file"/>
<div class="text-xs text-gray-500">Tip: keep multiple backups — export names include date/time automatically.</div>
</div>
</div>
<!-- Import confirm modal -->
<div class="hidden fixed inset-0 z-[100]" id="importConfirmModal">
<div class="absolute inset-0 bg-black/50" onclick="closeImportConfirm()"></div>
<div class="absolute inset-0 flex items-center justify-center p-4">
<div class="w-full max-w-md bg-white rounded-2xl shadow-xl p-5">
<div class="text-lg font-bold">Overwrite current data?</div>
<div class="text-sm text-gray-600 mt-2">Importing a backup will overwrite all Money Map data for the current profile on this device. This cannot be undone.</div>
<div class="flex gap-3 mt-5 justify-end">
<button class="px-4 py-2 rounded-lg bg-gray-100 hover:bg-gray-200" onclick="closeImportConfirm()">Cancel</button>
<button class="px-4 py-2 rounded-lg bg-red-600 text-white hover:bg-red-700" onclick="confirmImportOverwrite()">Yes, overwrite</button>
</div>
</div>
</div>
</div>
<!-- Item Modal -->
<div class="fixed inset-0 bg-black bg-opacity-40 hidden items-center justify-center z-50" id="itemModal">
<div class="bg-white rounded-2xl p-4 max-w-md w-full modal-panel">
<h3 class="font-bold text-lg mb-2">Edit Item</h3>
<label>Name</label>
<input class="w-full mb-2 p-2 border rounded" id="itemName"/>
<label>Amount ($)</label>
<input class="w-full mb-2 p-2 border rounded" id="itemAmount" type="number"/>
<label>Date</label>
<input class="w-full mb-2 p-2 border rounded" id="itemDate" type="date"/>
<label>Recurrence</label>
<select class="w-full mb-2 p-2 border rounded" id="itemRecurrence">
<option value="once">Once</option>
<option value="every_n_week">Every N week</option>
<option value="every_n_month">Every N month</option>
</select>
<label>N (for Every N week/month)</label>
<input class="w-full mb-3 p-2 border rounded" id="itemN" min="1" type="number" value="1"/>
<div class="border-t pt-3 mt-2">
<div class="text-sm font-semibold mb-2">Account Settings</div>
<div class="mb-2 hidden" id="incomeAccountRow">
<label>Deposit To (Debit Account)</label>
<select class="w-full p-2 border rounded" id="itemAccount"></select>
</div>
<div class="mb-2 hidden" id="expensePayRow">
<label>Paid With</label>
<select class="w-full p-2 border rounded" id="expensePayMethod" onchange="renderItemModalAccountFields()">
<option value="debit">Debit / Checking</option>
<option value="credit">Credit Card</option>
</select>
</div>
<div class="mb-2 hidden" id="expenseCategoryRow">
<label>Category</label>
<div class="flex gap-2">
<select class="flex-1 p-2 border rounded" id="expenseCategory"></select>
<button class="px-3 py-2 border rounded" onclick="openCategoryModal()" type="button">Manage</button>
</div>
</div>
<div class="mb-2 hidden" id="expenseDebitRow">
<label>Pay From (Debit Account)</label>
<select class="w-full p-2 border rounded" id="expenseDebitAccount"></select>
</div>
<div class="mb-2 hidden" id="expenseCreditRow">
<label>Charge To (Credit Card)</label>
<select class="w-full p-2 border rounded" id="expenseCreditAccount"></select>
<div class="text-xs text-gray-500 mt-1">
              This bill will affect cash on the card’s due date (from the Accounts page).
            </div>
</div>
</div>
<div class="flex justify-between space-x-2 mt-4">
<button class="px-4 py-2 bg-red-600 text-white rounded" id="itemDeleteBtn" onclick="deleteItemModal()">Delete</button>
<div class="flex space-x-2">
<button class="px-4 py-2 border rounded" onclick="closeItemModal()">Cancel</button>
<button class="px-4 py-2 bg-blue-600 text-white rounded" onclick="saveItemModal()">Save</button>
</div>
</div>
</div>
</div>
<!-- Account Modal -->
<div class="fixed inset-0 bg-black bg-opacity-40 hidden items-center justify-center z-50" id="accountModal">
<div class="bg-white rounded-2xl p-4 max-w-md w-full modal-panel">
<h3 class="font-bold text-lg mb-2">Edit Account</h3>
<label>Name</label>
<input class="w-full mb-2 p-2 border rounded" id="accountName"/>
<label>Type</label>
<select class="w-full mb-3 p-2 border rounded" id="accountType" onchange="renderAccountModalFields()">
<option value="debit">Debit / Checking</option>
<option value="credit">Credit Card</option>
</select>
<input id="accountCurrentBalance" type="hidden"/>
<div class="hidden" id="creditFields">
<label>Credit Card Payment Due Day (legacy) (1-28)</label>
<input class="w-full mb-2 p-2 border rounded" id="accountDueDay" max="28" min="1" type="number" value="1"/>
<label>Statement Close Day (1-28)</label>
<input class="w-full mb-2 p-2 border rounded" id="accountStatementCloseDay" max="28" min="1" type="number" value="1"/>
<input id="accountLastStatementBalance" type="hidden"/>
<label>Pay Card From (Debit Account)</label>
<select class="w-full mb-2 p-2 border rounded" id="accountPayFrom"></select>
<div class="text-xs text-gray-500">
            Bills you mark as “paid with this card” won’t reduce your forecast until the next due date after the bill date.
          </div>
</div>
<div class="flex justify-between space-x-2 mt-4">
<button class="px-4 py-2 bg-red-600 text-white rounded" onclick="deleteAccountModal()">Delete</button>
<div class="flex space-x-2">
<button class="px-4 py-2 border rounded" onclick="closeAccountModal()">Cancel</button>
<button class="px-4 py-2 bg-blue-600 text-white rounded" onclick="saveAccountModal()">Save</button>
</div>
</div>
</div>
</div>
<!-- Multi-Month Modal -->
<div class="fixed inset-0 bg-black bg-opacity-40 hidden items-center justify-center z-50" id="monthModal">
<div class="bg-white rounded-2xl p-4 max-w-3xl w-full modal-panel">
<div class="flex items-start justify-between gap-3">
<div>
<h3 class="font-bold text-lg leading-tight" id="monthModalTitle"></h3>
<div class="text-xs text-gray-500">Future income &amp; expenses for this month</div>
</div>
<button class="px-4 py-2 border rounded-lg" onclick="closeMonthModal()">Close</button>
</div>
<div class="mt-3 grid grid-cols-1 sm:grid-cols-3 gap-2">
<div class="p-3 rounded-xl bg-gray-50 border">
<div class="text-xs text-gray-500">End of month balance</div>
<div class="text-lg font-bold text-blue-600" id="monthModalBalance">$0.00</div>
</div>
<div class="p-3 rounded-xl bg-gray-50 border">
<div class="text-xs text-gray-500">Total future income</div>
<div class="text-lg font-bold text-green-700" id="monthModalTotalIncome">$0.00</div>
</div>
<div class="p-3 rounded-xl bg-gray-50 border">
<div class="text-xs text-gray-500">Total future expenses</div>
<div class="text-lg font-bold text-red-700" id="monthModalTotalBills">$0.00</div>
</div>
</div>
<div class="mt-3 grid grid-cols-1 md:grid-cols-2 gap-3">
<div class="border rounded-xl overflow-hidden bg-white">
<div class="px-3 py-2 bg-gray-100 font-semibold text-sm sticky top-0">Income</div>
<ul class="divide-y max-h-[45vh] overflow-auto text-sm" id="monthModalIncome"></ul>
</div>
<div class="border rounded-xl overflow-hidden bg-white">
<div class="px-3 py-2 bg-gray-100 font-semibold text-sm sticky top-0">Expenses</div>
<ul class="divide-y max-h-[45vh] overflow-auto text-sm" id="monthModalBills"></ul>
</div>
</div>
<div class="mt-3 border rounded-xl overflow-hidden bg-white">
<div class="px-3 py-2 bg-gray-100 font-semibold text-sm">Informational (paid by credit card)</div>
<ul class="divide-y text-sm transition-opacity duration-200" id="monthModalInfo"></ul>
<div class="px-3 py-2 bg-gray-50 text-sm flex items-center justify-between" id="monthModalInfoFooter">
<div class="text-gray-700 font-semibold">Subtotal</div>
<div class="text-gray-900 font-semibold" id="monthModalInfoTotal">$0.00</div>
</div>
</div>
<div class="mt-2 text-xs text-gray-500">
          Tip: Purple lines are credit card payments due (bills charged earlier).
        </div>
</div>
</div>
<!-- Day Modal -->
<div class="fixed inset-0 bg-black bg-opacity-40 hidden items-center justify-center z-50" id="dayModal">
<div class="bg-white rounded-2xl p-4 max-w-3xl w-full modal-panel">
<div class="flex items-start justify-between gap-3">
<div>
<h3 class="font-bold text-lg leading-tight" id="modalDate"></h3>
<div class="text-xs text-gray-500">Income &amp; expenses for this day</div>
</div>
<button class="px-4 py-2 border rounded-lg" onclick="closeDayModal()">Close</button>
</div>
<div class="mt-3 grid grid-cols-1 sm:grid-cols-3 gap-2">
<div class="p-3 rounded-xl bg-gray-50 border">
<div class="text-xs text-gray-500">Forecasted balance (end of day)</div>
<div class="text-lg font-bold text-blue-600" id="modalBalance">$0.00</div>
</div>
<div class="p-3 rounded-xl bg-gray-50 border">
<div class="text-xs text-gray-500">Total income</div>
<div class="text-lg font-bold text-green-700" id="dayModalTotalIncome">$0.00</div>
</div>
<div class="p-3 rounded-xl bg-gray-50 border">
<div class="text-xs text-gray-500">Total expenses (unpaid)</div>
<div class="text-lg font-bold text-red-700" id="dayModalTotalBills">$0.00</div>
</div>
</div>
<div class="mt-3 grid grid-cols-1 md:grid-cols-2 gap-3">
<div class="border rounded-xl overflow-hidden bg-white">
<div class="px-3 py-2 bg-gray-100 font-semibold text-sm sticky top-0">Income</div>
<ul class="divide-y text-sm transition-opacity duration-200" id="modalIncome"></ul>
</div>
<div class="border rounded-xl overflow-hidden bg-white">
<div class="px-3 py-2 bg-gray-100 font-semibold text-sm sticky top-0">Expenses</div>
<ul class="divide-y text-sm transition-opacity duration-200" id="modalBills"></ul>
</div>
</div>
<div class="mt-3 border rounded-xl overflow-hidden bg-white">
<div class="px-3 py-2 bg-gray-100 font-semibold text-sm">Informational (paid by credit card)</div>
<ul class="divide-y text-sm transition-opacity duration-200" id="dayModalInfo"></ul>
<div class="px-3 py-2 bg-gray-50 text-sm flex items-center justify-between" id="dayModalInfoFooter">
<div class="text-gray-700 font-semibold">Subtotal</div>
<div class="text-gray-900 font-semibold" id="dayModalInfoTotal">$0.00</div>
</div>
</div>
<div class="mt-2 text-xs text-gray-500">
          Tip: Toggle <span class="font-semibold">Paid</span> to exclude a bill from your forecast. Purple lines are credit card payment dues.
        </div>
</div>
</div>
<!-- Debt Modal -->
<div class="fixed inset-0 bg-black bg-opacity-40 hidden items-center justify-center z-50" id="debtModal">
<div class="bg-white rounded-2xl p-4 max-w-md w-full modal-panel">
<h3 class="font-bold text-lg mb-2">Edit Debt</h3>
<label>Name</label>
<input class="w-full mb-2 p-2 border rounded" id="debtName" placeholder="Chase Visa"/>
<label>Type</label>
<select class="w-full mb-2 p-2 border rounded" id="debtType">
<option value="credit_card">Credit Card</option>
<option value="loan">Loan</option>
</select>
<label>Current Balance ($)</label>
<div class="mb-2" id="debtLinkedCreditWrap">
<label>Linked credit card account (optional)</label>
<select class="w-full p-2 border rounded" id="debtLinkedCreditAccount"></select>
<div class="text-xs text-gray-500 mt-1">If linked, this debt will stay synced to the credit card account’s current balance and due day.</div>
</div>
<input class="w-full mb-2 p-2 border rounded" id="debtBalance" min="0" step="0.01" type="number"/>
<label>APR (%)</label>
<input class="w-full mb-2 p-2 border rounded" id="debtApr" min="0" placeholder="21.99" step="0.01" type="number"/>
<label>Minimum Monthly Payment ($)</label>
<input class="w-full mb-3 p-2 border rounded" id="debtMinPayment" min="0" step="0.01" type="number"/>
<label>Payment Due Day (1–28)</label>
<input class="w-full mb-3 p-2 border rounded" id="debtDueDay" max="28" min="1" placeholder="1" step="1" type="number"/>
<div class="text-xs text-gray-500 mb-3">Day of month the minimum payment is due. If this debt is linked to a credit card, the card’s due day is used.</div>
<!-- Principal Payment Plan (per-debt) -->
<div class="mb-3 p-3 rounded-xl bg-blue-50 border border-blue-200">
<div class="flex items-center justify-between">
<div>
<div class="font-semibold text-blue-800">Principal payment plan (optional)</div>
<div class="text-xs text-blue-700">Set extra principal payments for the next 5 years. These are saved with this debt.</div>
</div>
<button class="text-xs px-3 py-2 border border-blue-300 rounded-lg bg-white" onclick="_mm_clearDebtPrincipalScheduleInputs()" type="button">Clear</button>
</div>
<div class="mt-2 max-h-56 overflow-auto rounded-lg border bg-white">
<table class="w-full text-sm">
<thead class="sticky top-0 bg-gray-50 border-b">
<tr>
<th class="p-2 text-left">Month</th>
<th class="p-2 text-right">Extra principal</th>
</tr>
</thead>
<tbody id="debtPrincipalScheduleBody"></tbody>
</table>
</div>
<div class="mt-2 text-xs text-gray-600" id="debtPrincipalScheduleHint"></div>
</div>
<div class="text-xs text-gray-500 mb-3">
          Tip: APR and minimum payment are key for payoff math.
        </div>
<div class="mb-3 p-3 rounded-xl bg-gray-50 border" id="debtModalSummary">
<div class="grid grid-cols-3 gap-2 text-sm">
<div>
<div class="text-xs text-gray-500">Debt-free</div>
<div class="font-bold" id="debtModalDebtFree">—</div>
</div>
<div>
<div class="text-xs text-gray-500">Months</div>
<div class="font-bold" id="debtModalMonths">—</div>
</div>
<div>
<div class="text-xs text-gray-500">Total interest</div>
<div class="font-bold" id="debtModalInterest">—</div>
</div>
</div>
<div class="text-xs text-gray-500 mt-2" id="debtModalSummaryNote"></div>
</div>
<div class="flex justify-between space-x-2 mt-4">
<button class="px-4 py-2 bg-red-600 text-white rounded" onclick="deleteDebtModal()">Delete</button>
<div class="flex space-x-2">
<button class="px-4 py-2 border rounded" onclick="closeDebtModal()">Cancel</button>
<button class="px-4 py-2 bg-blue-600 text-white rounded" onclick="saveDebtModal()">Save</button>
</div>
</div>
</div>
</div>
<!-- Debt Plan Month Breakdown Modal -->
<div class="fixed inset-0 bg-black bg-opacity-40 hidden items-center justify-center z-50" id="debtPlanMonthModal">
<div class="bg-white rounded-2xl p-4 max-w-md w-full modal-panel">
<h3 class="font-bold text-lg mb-2" id="debtPlanMonthTitle"></h3>
<!-- Month picker -->
<div class="mb-2">
<div class="text-xs text-gray-500 mb-1">Jump to month</div>
<div class="flex gap-2 overflow-auto pb-1" id="dpMonthPicker"></div>
</div>
<div class="flex justify-between mb-3">
<button class="px-3 py-2 border rounded-lg text-sm" onclick="dpPrevMonth()">← Prev</button>
<button class="px-3 py-2 border rounded-lg text-sm" onclick="dpNextMonth()">Next →</button>
</div>
<div class="grid grid-cols-3 gap-2 mb-3">
<div class="p-3 rounded-xl bg-gray-50 border">
<div class="text-xs text-gray-500">Total Payment</div>
<div class="font-bold" id="dpTotalPayment">—</div>
</div>
<div class="p-3 rounded-xl bg-gray-50 border">
<div class="text-xs text-gray-500">Interest Added</div>
<div class="font-bold" id="dpInterestAdded">—</div>
</div>
<div class="p-3 rounded-xl bg-gray-50 border">
<div class="text-xs text-gray-500">Remaining Total</div>
<div class="font-bold" id="dpRemainingTotal">—</div>
</div>
</div>
<div class="text-sm font-semibold mb-1">Payments (by debt)</div>
<ul class="list-disc ml-4 max-h-40 overflow-auto text-sm mb-3" id="dpPaymentsList"></ul>
<div class="text-sm font-semibold mb-1">End-of-month balances</div>
<ul class="list-disc ml-4 max-h-40 overflow-auto text-sm" id="dpBalancesList"></ul>
<div class="flex justify-end mt-4">
<button class="px-4 py-2 border rounded" onclick="closeDebtPlanMonthModal()">Close</button>
</div>
</div>
</div>
</div>
</div>
<!-- Debt Plan Preview Modal (per debt) -->
<div class="fixed inset-0 bg-black bg-opacity-40 hidden items-center justify-center z-50" id="debtPlanPreviewModal">
<div class="bg-white rounded-2xl p-4 max-w-3xl w-full modal-panel">
<div class="flex items-start justify-between gap-3">
<div>
<h3 class="font-bold text-lg leading-tight" id="debtPlanPreviewTitle"></h3>
<div class="text-xs text-gray-500">5-year preview based on your current strategy and extra payment.</div>
</div>
<div class="flex gap-2">
<button class="px-4 py-2 border rounded-lg" onclick="closeDebtPlanPreviewModal()">Close</button>
</div>
</div>
<div class="mt-3 grid grid-cols-1 sm:grid-cols-3 gap-2">
<div class="p-3 rounded-xl bg-gray-50 border">
<div class="text-xs text-gray-500">Debt-free</div>
<div class="text-lg font-bold" id="debtPreviewDebtFree">—</div>
</div>
<div class="p-3 rounded-xl bg-gray-50 border">
<div class="text-xs text-gray-500">Months</div>
<div class="text-lg font-bold" id="debtPreviewMonths">—</div>
</div>
<div class="p-3 rounded-xl bg-gray-50 border">
<div class="text-xs text-gray-500">Total interest</div>
<div class="text-lg font-bold" id="debtPreviewInterest">—</div>
</div>
</div>
<div class="text-xs text-gray-500 mt-2" id="debtPreviewNote"></div>
<div class="mt-3 overflow-auto border rounded-lg bg-white">
<table class="w-full text-sm">
<thead class="bg-gray-100 sticky top-0">
<tr>
<th class="p-2 text-left">Date (Month-Year)</th>
<th class="p-2 text-right">Minimum</th>
<th class="p-2 text-right">Extra</th>
<th class="p-2 text-right">Interest Added</th>
<th class="p-2 text-right">Remaining Total</th>
</tr>
</thead>
<tbody id="debtPlanPreviewBody"></tbody>
</table>
</div>
</div>
<!-- Principal Payment Schedule Modal -->
<div class="fixed inset-0 bg-black bg-opacity-40 hidden items-center justify-center z-50" id="principalScheduleModal">
<div class="bg-white rounded-2xl p-4 max-w-3xl w-full modal-panel">
<div class="flex items-start justify-between gap-3">
<div>
<h3 class="font-bold text-lg leading-tight">Principal Payment Schedule</h3>
<div class="text-xs text-gray-500" id="principalScheduleDebtName"></div>
<div class="mt-2 grid grid-cols-1 sm:grid-cols-2 gap-2">
<div>
<div class="text-xs text-gray-500 mb-1">Payment day for this debt (1–28)</div>
<input class="w-full p-2 border rounded" id="principalSchedulePayDay" max="28" min="1" oninput="onPrincipalSchedulePayDayChanged(this.value)" type="number" value="1"/>
</div>
<div class="text-xs text-gray-500 flex items-end">
    This schedule is per-debt. Amounts apply only to the month you enter.
  </div>
</div>
<div class="text-xs text-gray-500">Set a custom principal payment for each month (next 5 years).</div>
</div>
<button class="px-4 py-2 border rounded-lg" onclick="closePrincipalScheduleModal()">Close</button>
</div>
<div class="mt-3 overflow-auto border rounded-lg bg-white">
<table class="w-full text-sm">
<thead class="bg-gray-100 sticky top-0">
<tr>
<th class="p-2 text-left">Month</th>
<th class="p-2 text-right">Principal payment</th>
</tr>
</thead>
<tbody id="principalScheduleBody"></tbody>
</table>
</div>
<div class="mt-3 flex flex-col sm:flex-row gap-2 sm:items-center sm:justify-between">
<div class="text-xs text-gray-500" id="principalScheduleHint"></div>
<button class="w-full sm:w-auto bg-blue-600 text-white px-4 py-2 rounded-lg font-semibold" onclick="applyPrincipalScheduleToForecast()">
            Apply plan to forecast
          </button>
</div>
</div>
</div>
</div>
<style>
  .calendar-grid { display:grid; grid-template-columns:repeat(7,1fr); gap:2px; }
  .calendar-day { border:1px solid #ddd; min-height:60px; padding:2px; cursor:pointer; overflow:hidden; border-radius:4px; }

  /* Toggle switch (no Tailwind peer dependency) */
  .mm-switch{ position:relative; display:inline-block; width:44px; height:26px; flex:0 0 auto; }
  .mm-switch input{ opacity:0; width:0; height:0; }
  .mm-switch .mm-slider{
    position:absolute; inset:0; cursor:pointer;
    background:#E5E7EB; border-radius:999px; transition:.18s;
  }
  .mm-switch .mm-slider:before{
    content:""; position:absolute; height:20px; width:20px; left:3px; top:50%;
    transform:translateY(-50%); background:white; border-radius:999px; transition:.18s;
    box-shadow: 0 1px 2px rgba(0,0,0,.18);
  }
  .mm-switch input:checked + .mm-slider{ background:#2563EB; }
  .mm-switch input:checked + .mm-slider:before{ transform:translate(18px,-50%); }

  /* Make modals scroll on smaller/laptop viewports (Chrome) */
  .modal-panel{
    max-height: 85vh;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
  }

</style>
<script>
/* ===========================
   MONEY MAP - HARDENING LAYER
   (for production / Play Store)
   =========================== */
'use strict';

// Show a clear on-screen error (instead of a blank app)
function __mm_showFatalError(userMessage, err) {
  try {
    console.error('[Money Map Fatal]', userMessage, err || '');
    var existing = document.getElementById('__mmFatal');
    if (existing) existing.remove();

    var wrap = document.createElement('div');
    wrap.id = '__mmFatal';
    wrap.style.position = 'fixed';
    wrap.style.inset = '0';
    wrap.style.zIndex = '99999';
    wrap.style.background = 'rgba(0,0,0,0.65)';
    wrap.style.display = 'flex';
    wrap.style.alignItems = 'center';
    wrap.style.justifyContent = 'center';
    wrap.style.padding = '16px';

    var card = document.createElement('div');
    card.style.maxWidth = '720px';
    card.style.width = '100%';
    card.style.background = '#ffffff';
    card.style.borderRadius = '16px';
    card.style.boxShadow = '0 20px 60px rgba(0,0,0,0.35)';
    card.style.padding = '18px';

    var h = document.createElement('div');
    h.style.fontWeight = '800';
    h.style.fontSize = '18px';
    h.style.marginBottom = '8px';
    h.textContent = 'Money Map hit an error';

    var p = document.createElement('div');
    p.style.color = '#111827';
    p.style.fontSize = '14px';
    p.style.lineHeight = '1.35';
    p.textContent = userMessage || 'Something went wrong. Your data should still be on this device.';

    var hint = document.createElement('div');
    hint.style.marginTop = '12px';
    hint.style.fontSize = '13px';
    hint.style.color = '#374151';
    hint.innerHTML = '<b>Tip:</b> Go to <b>Backup</b> to export your data, then reopen the app. If this happened after an update, switch profiles and try again.';

    var details = document.createElement('pre');
    details.style.marginTop = '12px';
    details.style.whiteSpace = 'pre-wrap';
    details.style.wordBreak = 'break-word';
    details.style.background = '#f3f4f6';
    details.style.borderRadius = '12px';
    details.style.padding = '10px';
    details.style.fontSize = '12px';
    details.style.maxHeight = '240px';
    details.style.overflow = 'auto';
    details.textContent = (err && (err.stack || err.message)) ? (err.stack || err.message) : '';

    var btnRow = document.createElement('div');
    btnRow.style.display = 'flex';
    btnRow.style.gap = '10px';
    btnRow.style.marginTop = '14px';
    btnRow.style.flexWrap = 'wrap';

    function mkBtn(txt, onClick) {
      var b = document.createElement('button');
      b.textContent = txt;
      b.style.padding = '10px 12px';
      b.style.borderRadius = '12px';
      b.style.border = '1px solid #d1d5db';
      b.style.background = '#ffffff';
      b.style.fontWeight = '600';
      b.onclick = onClick;
      return b;
    }

    btnRow.appendChild(mkBtn('Reload', function(){ location.reload(); }));
    btnRow.appendChild(mkBtn('Close', function(){ wrap.remove(); }));

    card.appendChild(h);
    card.appendChild(p);
    if (details.textContent) card.appendChild(details);
    card.appendChild(hint);
    card.appendChild(btnRow);

    wrap.appendChild(card);
    document.body.appendChild(wrap);
  } catch(e) {
    // last resort
    alert(userMessage || 'Money Map hit an error.');
  }
}

// Catch runtime errors so the app never silently "goes blank"
window.addEventListener('error', function (event) {
  // Many errors are noisy; only show fatal screen for script errors
  __mm_showFatalError('A script error stopped the app from running. Your data should still be stored on this device.', event.error || event.message);
});

window.addEventListener('unhandledrejection', function (event) {
  __mm_showFatalError('An unexpected error occurred. Your data should still be stored on this device.', event.reason);
});

// Basic sanity check: if core functions are missing, show a helpful error
function __mm_sanityCheck() {
  try {
    var required = ['toggleMenu','showTab','exportData','importData','switchProfile','openProfileModal'];
    for (var i=0;i<required.length;i++){
      if (typeof window[required[i]] !== 'function') {
        __mm_showFatalError('A required function is missing (' + required[i] + '). This usually means a code update failed to load.', new Error('Missing: '+required[i]));
        return;
      }
    }
  } catch (e) {}
}

document.addEventListener('DOMContentLoaded', function(){
  try{
    // Initialize sidebar highlight to Dashboard
    setTimeout(()=>{ try{ showTab('dashboard'); }catch(e){} }, 0);
  }catch(e){}

  
    
    
    const _mmDebtLinkSel = document.getElementById('debtLinkedCreditAccount');
    if (_mmDebtLinkSel) _mmDebtLinkSel.addEventListener('change', _mm_applyDebtDueDayLinkingLock);

    const _mmDebtTypeSel = document.getElementById('debtType');
    if (_mmDebtTypeSel) _mmDebtTypeSel.addEventListener('change', _mm_applyDebtDueDayLinkingLock);
setTimeout(()=>{ try{ renderSafeExtraByMonth(); }catch(e){} }, 0);

  // Sweep mode removed/disabled
  try{ if(window.debtPlan){ debtPlan.sweepMode = false; } }catch(e){}

  setTimeout(__mm_sanityCheck, 0);
});
/* ===== End Hardening Layer ===== */

/**
 * DATA MODEL (stored in localStorage):
 * - accounts: [{id, name, type:'debit'|'credit', dueDay?, payFromAccountId?}]
 * - incomes:  [{name, amount, date, recurrence, n, accountId}]               // deposit to debit acct (optional)
 * - expenses: [{name, amount, date, recurrence, n, payMethod, debitAccountId, creditAccountId}]
 *
 * FORECAST RULE:
 * - debit-paid bills hit cash on the bill date
 * - credit-paid bills hit cash on the NEXT credit-card due date after the bill date
 */

let accounts = [];
let incomes = [], expenses = [], currentItem=null, currentAccount=null;
let billCategories = [];
let paidOccurrences = {}; // { "YYYY-MM-DD|expenseId": true } per active profile
let dailyBalances=[], multiMonthData=[], currentBalance=0;
let currentDayModalDate = null;
let dayModalRenderToken = 0;

let debts = [];
let currentDebt=null;

// Charts
let monthlyBarChart = null;
let billsPieChart = null;

// Pie slice labels (percentage + category) plugin
const pieSliceLabelPlugin = {
  id: 'pieSliceLabelPlugin',
  afterDatasetsDraw(chart) {
    if (!chart || !chart.data || !chart.data.datasets || !chart.data.datasets.length) return;

    const ctx = chart.ctx;
    const dataset = chart.data.datasets[0];
    const meta = chart.getDatasetMeta(0);
    if (!meta || !meta.data) return;

    const data = (dataset.data || []).map(v => Number(v) || 0);
    const total = data.reduce((a,b)=>a+b,0);
    if (total <= 0) return;

    ctx.save();
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 12px system-ui, -apple-system, Segoe UI, Roboto, Arial';

    meta.data.forEach((arc, i) => {
      const value = data[i] || 0;
      if (value <= 0) return;

      const pct = Math.round((value / total) * 100);
      if (pct < 3) return; // skip tiny slices to avoid clutter

      const label = (chart.data.labels && chart.data.labels[i]) ? String(chart.data.labels[i]) : '';
      const pos = arc.tooltipPosition();

      // Subtle shadow for readability
      ctx.shadowColor = 'rgba(0,0,0,0.35)';
      ctx.shadowBlur = 3;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 1;

      const maxLen = 14;
      const safeLabel = label.length > maxLen ? label.slice(0, maxLen-1) + '…' : label;

      ctx.fillText(safeLabel, pos.x, pos.y - 8);
      ctx.fillText(`${pct}%`, pos.x, pos.y + 8);
    });

    ctx.restore();
  }
};

let billsSelectedMonthIndex = -1;

// Debt plan settings
let debtPlan = {
  strategy: 'avalanche',
  extraMonthly: 0,
  applyToForecast: false,
  payDay: 1,
  generatedExpenseIds: []
};

// Last simulation (for modal)
let lastDebtSim = null;
let lastDebtSimBaseMonth = null;
let currentDebtPlanMonthOffset = 0;


/* =========================
   Per-debt Principal Schedule (from Preview)
   ========================= */
let _mm_principalScheduleDebtId = null;
window._mm_currentPreviewDebtId = null;

function _mm_monthKeyFromYM(y, m){ return `${y}-${String(m).padStart(2,'0')}`; }

function _mm_next12MonthKeysFromNow(){
  const now = new Date();
  const keys = [];
  for(let i=0; i<60; i++){
    const d = new Date(now.getFullYear(), now.getMonth()+i, 1);
    keys.push(_mm_monthKeyFromYM(d.getFullYear(), d.getMonth()+1));
  }
  return keys;
}

function _mm_getDebtById(id){
  return (debts||[]).find(d=>d && d.id===id) || null;
}

function _mm_getDebtPayDay(d){
  const v = Number(d?.payDay || 1);
  return Math.max(1, Math.min(28, isFinite(v)?v:1));
}

function _mm_getPrincipalStoreByDebtId(){
  if(!debtPlan) debtPlan = {};
  if(!debtPlan.principalByDebtId || typeof debtPlan.principalByDebtId !== 'object'){
    debtPlan.principalByDebtId = {}; // debtId -> { 'YYYY-MM': number }
  }
  return debtPlan.principalByDebtId;
}

function _mm_getPrincipalForDebtMonth(debtObj, monthKey){
  try{
    // 1) per-debt map on debt object
    const map = _mm_getDebtPrincipalScheduleMap(debtObj);
    const v1 = Number(map?.[monthKey] || 0) || 0;
    if(v1>0) return v1;

    // 2) fallback store by debtId
    const store = _mm_getPrincipalStoreByDebtId();
    const did = debtObj?.id;
    const map2 = (did && store && store[did]) ? store[did] : null;
    const v2 = Number(map2?.[monthKey] || 0) || 0;
    return v2>0 ? v2 : 0;
  }catch(e){ return 0; }
}


/* ===========================
   Principal Plan (Debt Modal)
   =========================== */
function _mm_renderDebtPrincipalScheduleTable(debtObj){
  try{
    const body = document.getElementById('debtPrincipalScheduleBody');
    const hint = document.getElementById('debtPrincipalScheduleHint');
    if(!body) return;

    const keys = _mm_next12MonthKeysFromNow();
    const map = _mm_getDebtPrincipalScheduleMap(debtObj);

    body.innerHTML = '';
    let sum = 0;

    keys.forEach((k, idx)=>{
      const [yy, mm] = k.split('-').map(x=>parseInt(x,10));
      const labelDate = new Date(yy, mm-1, 1);
      const label = labelDate.toLocaleString(undefined,{month:'short', year:'numeric'});
      const amt = Number(map?.[k] || 0) || 0;
      sum += amt;

      const tr = document.createElement('tr');
      tr.className = 'border-t';
      tr.innerHTML = `
        <td class="p-2 text-left">${label}</td>
        <td class="p-2 text-right">
          <input type="number" inputmode="decimal" class="w-28 p-2 border rounded text-right"
                 id="debtps_amt_${idx}" value="${amt}" min="0" step="0.01"/>
        </td>
      `;
      body.appendChild(tr);

      // Live-update payoff stats while editing the principal plan
      try{
        const inp = tr.querySelector('input');
        if(inp){
          inp.addEventListener('input', ()=>{
            try{ if(window.currentDebt && window.currentDebt.id) renderDebtModalStats(window.currentDebt.id); }catch(e){}
          });
          inp.addEventListener('change', ()=>{
            try{ if(window.currentDebt && window.currentDebt.id) renderDebtModalStats(window.currentDebt.id); }catch(e){}
          });
        }
      }catch(e){}
    });

    if(hint){
      hint.textContent = (sum>0)
        ? `Total scheduled extra principal (next 5 years): ${formatCurrency(sum)}`
        : `No extra principal scheduled.`;
    }
  }catch(e){
    console.error('render debt principal schedule failed', e);
  }
}

// Read (but do not persist) the principal schedule currently typed into the debt modal table.
function _mm_getDebtPrincipalScheduleFromModalInputs(){
  try{
    const keys = _mm_next12MonthKeysFromNow();
    const map = {};
    keys.forEach((k, idx)=>{
      const el = document.getElementById('debtps_amt_'+idx);
      const v = parseFloat(el?.value||'0')||0;
      if(isFinite(v) && v>0) map[k] = v;
    });
    return map;
  }catch(e){
    return {};
  }
}

function _mm_saveDebtPrincipalScheduleFromModal(debtObj){
  try{
    if(!debtObj) return;
    const keys = _mm_next12MonthKeysFromNow();
    const map = {};
    let sum = 0;

    keys.forEach((k, idx)=>{
      const el = document.getElementById('debtps_amt_'+idx);
      const v = parseFloat(el?.value||'0')||0;
      if(isFinite(v) && v>0){
        map[k] = v;
        sum += v;
      }
    });

    debtObj.principalSchedule = map;

    // also maintain the fallback store used by _mm_getPrincipalForDebtMonth
    try{
      const store = _mm_getPrincipalStoreByDebtId();
      if(!store[debtObj.id] || typeof store[debtObj.id] !== 'object') store[debtObj.id] = {};
      // overwrite month keys for this debt
      store[debtObj.id] = {...map};
    }catch(e){}

    // refresh hint
    const hint = document.getElementById('debtPrincipalScheduleHint');
    if(hint){
      hint.textContent = (sum>0)
        ? `Total scheduled extra principal (next 5 years): ${formatCurrency(sum)}`
        : `No extra principal scheduled.`;
    }
  }catch(e){
    console.error('save debt principal schedule failed', e);
  }
}

function _mm_clearDebtPrincipalScheduleInputs(){
  try{
    const body = document.getElementById('debtPrincipalScheduleBody');
    if(!body) return;
    const inputs = body.querySelectorAll('input[type="number"]');
    inputs.forEach(i=> i.value = '');
    // also clear in-memory for currently open debt/draft
    const id = currentDebt?.id;
    const d = _mm_getDebtById(id) || window.__debtDraft;
    if(d){
      d.principalSchedule = {};
      try{ const store = _mm_getPrincipalStoreByDebtId(); if(store && d.id) store[d.id] = {}; }catch(e){}
    }
    const hint = document.getElementById('debtPrincipalScheduleHint');
    if(hint) hint.textContent = 'No extra principal scheduled.';
  }catch(e){}
}

// Read (but do not persist) the principal schedule currently typed into the Debt Modal.
function _mm_readDebtPrincipalScheduleFromModalInputs(){
  try{
    const keys = _mm_next12MonthKeysFromNow();
    const map = {};
    keys.forEach((k, idx)=>{
      const el = document.getElementById('debtps_amt_'+idx);
      const v = parseFloat(el?.value||'0')||0;
      if(isFinite(v) && v>0) map[k] = v;
    });
    return map;
  }catch(e){
    return {};
  }
}


function _mm_renderDebtLinkedCreditAccountSelect(debtObj){
  const sel = document.getElementById('debtLinkedCreditAccount');
  const wrap = document.getElementById('debtLinkedCreditWrap');
  if(!sel || !wrap) return;

  // Allow LOANS to link to ANY account. Credit-card debts still default to credit accounts.
  const isLoan = (debtObj?.type === 'loan');
  const candidates = isLoan
    ? (accounts||[]).filter(a=>a && a.id)
    : (accounts||[]).filter(a=>a && a.id && a.type==='credit');

  wrap.style.display = (candidates.length ? '' : 'none');

  sel.innerHTML = '';
  const optNone = document.createElement('option');
  optNone.value = '';
  optNone.textContent = 'Not linked';
  sel.appendChild(optNone);

  candidates.forEach(a=>{
    const opt = document.createElement('option');
    opt.value = a.id;
    const labelType = a.type ? ` (${a.type})` : '';
    opt.textContent = (a.name || 'Account') + labelType;
    sel.appendChild(opt);
  });

  // Set selection
  const linkedId = debtObj?.linkedCreditAccountId || '';
  sel.value = linkedId || '';

  // For credit-card debts linked to credit accounts, autofill due day from the card.
  // For loans, do NOT override the debt's due day automatically.
  try{
    const dueEl = document.getElementById('debtDueDay');
    if(!dueEl) return;

    if(!isLoan && sel.value){
      const acc = (accounts||[]).find(a=>a && a.id===sel.value && a.type==='credit');
      const dd = clamp(parseInt(acc?.dueDay || acc?.ccDueDay || acc?.paymentDueDay || 0,10)||0,1,28);
      if(dd>=1 && dd<=28) dueEl.value = dd;
    }

    // User can always edit the due day field
    dueEl.disabled = false;
    dueEl.removeAttribute('disabled');
  }catch(e){}
};

function _mm_getLinkedCreditAccountForDebt(debt){
  try{
    if(!debt) return null;
    // Explicit link wins
    if(debt.linkedCreditAccountId){
      const acc = (accounts||[]).find(a=>a && a.id===debt.linkedCreditAccountId);
      if(acc) return acc;
    }
    // Try match by name among credit accounts
    const dname = String(debt.name||'').trim().toLowerCase();
    const creditAccounts = (accounts||[]).filter(a=>a && a.type==='credit');
    if(dname){
      // exact name match
      let acc = creditAccounts.find(a=>String(a.name||'').trim().toLowerCase()===dname);
      if(acc) return acc;
      // loose contains match
      acc = creditAccounts.find(a=>String(a.name||'').trim().toLowerCase().includes(dname) || dname.includes(String(a.name||'').trim().toLowerCase()));
      if(acc) return acc;
    }
    // If there is exactly one credit account, assume it's the one
    if(creditAccounts.length===1) return creditAccounts[0];
    return null;
  }catch(e){ return null; }
}



function _mm_getDebtPrincipalScheduleMap(d){
  if(!d) return {};
  if(!d.principalSchedule || typeof d.principalSchedule !== 'object') d.principalSchedule = {};
  return d.principalSchedule;
}


function _mm_getPrincipalForMonth(debtObj, monthKey){
  try{
    // Preferred: map with 'YYYY-MM' keys
    const map = _mm_getDebtPrincipalScheduleMap(debtObj);
    let v = Number(map?.[monthKey] || 0) || 0;

    if(v>0) return Math.max(0, v);

    // Legacy key style: 'Mon YYYY' (e.g., 'Feb 2026')
    const dt = new Date(monthKey + '-01');
    if(!isNaN(dt)){
      const monLabel = dt.toLocaleString(undefined, {month:'short', year:'numeric'});
      v = Number(map?.[monLabel] || 0) || 0;
      if(v>0) return Math.max(0, v);
    }

    // Legacy: array stored on debt.principalScheduleArray aligned to "next 5 years"
    const arr = debtObj?.principalScheduleArray;
    if(Array.isArray(arr) && arr.length){
      // Compute month index relative to now
      const now = new Date();
      const base = new Date(now.getFullYear(), now.getMonth(), 1);
      const target = new Date(monthKey + '-01');
      if(!isNaN(target)){
        const idx = (target.getFullYear()-base.getFullYear())*12 + (target.getMonth()-base.getMonth());
        const val = Number(arr[idx] || 0) || 0;
        if(val>0) return Math.max(0, val);
      }
    }

    // Legacy: numeric single extraMonthly used everywhere (ignore; we only want explicit month entries)
    return 0;
  }catch(e){ return 0; }
}


function openPrincipalScheduleForPreviewDebt(){
  const id = window._mm_currentPreviewDebtId;
  if(!id){ alert('Open a debt preview first.'); return; }
  openPrincipalScheduleModal(id);
}

function openPrincipalScheduleModal(debtId){
  const d = _mm_getDebtById(debtId);
  if(!d){ alert('Debt not found'); return; }

  _mm_principalScheduleDebtId = debtId;

  const nameEl = document.getElementById('principalScheduleDebtName');
  if(nameEl) nameEl.textContent = `Debt: ${d.name || 'Unnamed'}`;

  const payDayEl = document.getElementById('principalSchedulePayDay');
  if(payDayEl) payDayEl.value = _mm_getDebtPayDay(d);

  const body = document.getElementById('principalScheduleBody');
  if(!body) return;
  body.innerHTML = '';

  const keys = _mm_next12MonthKeysFromNow();
  const map = _mm_getDebtPrincipalScheduleMap(d);

  keys.forEach((k, idx)=>{
    const [yy, mm] = k.split('-').map(x=>parseInt(x,10));
    const labelDate = new Date(yy, mm-1, 1);
    const label = labelDate.toLocaleString(undefined,{month:'short', year:'numeric'});

    const amt = Number(map[k] || 0) || 0;
    const tr = document.createElement('tr');
    tr.className = 'border-t';
    tr.innerHTML = `
      <td class="p-2 text-left">${label}</td>
      <td class="p-2 text-right">
        <input type="number" inputmode="decimal" class="w-28 p-2 border rounded text-right"
               id="ps_amt_${idx}" value="${amt}" />
      </td>
    `;
    body.appendChild(tr);
  });

  const modal = document.getElementById('principalScheduleModal');
  if(modal) modal.classList.remove('hidden');
}

function onPrincipalSchedulePayDayChanged(val){
  const d = _mm_getDebtById(_mm_principalScheduleDebtId);
  if(!d) return;
  d.payDay = Math.max(1, Math.min(28, Number(val)||1));
  saveData();
}

function applyPrincipalScheduleToForecast(){
  const d = _mm_getDebtById(_mm_principalScheduleDebtId);
  if(!d){ closePrincipalScheduleModal(); return; }

  const keys = _mm_next12MonthKeysFromNow();
  const map = _mm_getDebtPrincipalScheduleMap(d);

  // payment day for this debt
  try{
    const payDayEl = document.getElementById('principalSchedulePayDay');
    const payDay = Math.min(28, Math.max(1, parseInt(payDayEl?.value||0)||1));
    debtPlan.payDay = payDay; // global extra-payment day
    // d.payDay is reserved for per-debt due day now; do not overwrite here.
  }catch(e){}

  // fallback store by debtId for robustness
  const store = _mm_getPrincipalStoreByDebtId();
  if(!store[d.id] || typeof store[d.id] !== 'object') store[d.id] = {};


  keys.forEach((k, idx)=>{
    const el = document.getElementById('ps_amt_'+idx);
    const v = parseFloat(el?.value||'0')||0;
    if(isFinite(v) && v>0) map[k] = v;
    else delete map[k];
  });

  d.principalSchedule = map;
  saveData();


  try{ computeForecast(); }catch(e){}
  try{ renderAll(); }catch(e){}
  // refresh preview if open
  try{ if(window._mm_currentPreviewDebtId === d.id) openDebtPlanPreviewModal(d.id); }catch(e){}
  closePrincipalScheduleModal();
}


function _mm_expensePayLabel(exp){
  try{
    const disp = exp?._displayPayMethod;
    if(disp==='credit') return 'Credit Card (payment)';
    // fall back to existing logic
    const pm = exp?.payMethod || 'debit';
    if(pm==='credit') return 'Credit card';
    return 'Cash / debit';
  }catch(e){ return 'Cash / debit'; }
}


function syncLinkedCreditCardDebtBalances(){
  try{
    if(!Array.isArray(debts) || !Array.isArray(accounts)) return;
    const creditById = {};
    accounts.forEach(a=>{ if(a && a.type==='credit') creditById[a.id]=a; });

    debts.forEach(d=>{
      if(!d) return;
      const accId = d.linkedCreditAccountId;
      if(!accId) return;
      const acc = creditById[accId];
      if(!acc) return;

      const accBal = parseFloat(acc.currentBalance||'0')||0;
      const debtBal = parseFloat((d.balance!=null?d.balance:d.currentBalance)||'0')||0;

      // Strict sync: debt balance mirrors linked credit account current balance
      if(debtBal !== accBal){
        d.balance = accBal;
        // Back-compat for any legacy reads
        d.currentBalance = accBal;
      } else {
        // Keep back-compat aligned
        d.currentBalance = accBal;
      }
    });
  }catch(e){}
}

// ---------- Utilities ----------
function uuid(){
  // simple id: time + random
  return 'id_' + Date.now().toString(36) + '_' + Math.random().toString(36).slice(2,8);
}
function formatDate(d){ return d.toISOString().split('T')[0]; }
function parseDate(yyyy_mm_dd){
  const [y,m,da] = (yyyy_mm_dd||'').split('-').map(x=>parseInt(x,10));
  if(!y || !m || !da) return new Date();
  return new Date(y, m-1, da);
}
function money(n){ return `$${(parseFloat(n)||0).toFixed(2)}`; }
function clamp(n,min,max){ return Math.max(min, Math.min(max, n)); }

// ---------- Debt Plan Preview Scenario (compare sweep vs fixed) ----------
window._mm_debtPreviewScenario = window._mm_debtPreviewScenario || 'current';
window._mm_currentPreviewDebtId = window._mm_currentPreviewDebtId || null;

function updateDebtPlanPreviewScenario(mode){
  window._mm_debtPreviewScenario = (mode === 'fixed') ? mode : 'current';
  // Re-render the open preview modal if one is active
  if(window._mm_currentPreviewDebtId){
    openDebtPlanPreviewModal(window._mm_currentPreviewDebtId);
  }
}

// Ensure the dropdown reflects stored scenario whenever the modal opens
function _mm_syncDebtPreviewScenarioUI(){
  const sel = document.getElementById('debtPreviewScenario');
  if(!sel) return;
  sel.value = window._mm_debtPreviewScenario || 'current';
}

// ---------- Debt Planner toggle persistence ----------
function onApplyPlanToggleChange(checked){
  try{
    debtPlan.applyToForecast = !!checked;
    saveData();
  }catch(e){}
  try{ renderDebtPlanner(); }catch(e){}
  // Applying plan changes forecast, so recompute & refresh key views
  try{ computeForecast(); }catch(e){}
  try{ window.__ccBuckets = ccBuckets;
  renderCalendar(); }catch(e){}
  try{ renderMultiMonth(); }catch(e){}
  try{ renderMonthlyForecastChart(); }catch(e){}
}
function onSweepModeToggleChange(){ /* sweep mode removed */ }

function onDebtBufferChange(val){
  // Keep safe-extra buffer as-is (select already drives UI), but also store for sweep mode logic
  try{
    debtPlan.sweepBuffer = Number(val)||0;
    saveData();
  }catch(e){}
  try{ renderDebtPlanner(); }catch(e){}
}

// ---------- Sweep Preview / Mini Strip (stable) ----------
function toggleSweepPreview(){
  const wrap = document.getElementById('sweepPreviewWrap');
  if(!wrap) return;
  wrap.classList.toggle('hidden');
}
function _mm_monthKey(d){
  const y = d.getFullYear();
  const m = d.getMonth()+1;
  return `${y}-${String(m).padStart(2,'0')}`;
}
function _mm_monthLabel(d){
  return d.toLocaleString(undefined, {month:'short', year:'numeric'});
}
function _mm_getMonthDaysFromDailyBalances(){
  const db = _mm_getDailyBalances();
  if(!Array.isArray(db) || !db.length) return {};
  const byMonth = {};
  db.forEach(o=>{
    if(!o || !o.date) return;
    const dt = (o.date instanceof Date) ? o.date : new Date(o.date);
    const k = _mm_monthKey(dt);
    (byMonth[k] ||= []).push({...o, __dt: dt});
  });
  Object.keys(byMonth).forEach(k=> byMonth[k].sort((a,b)=>a.__dt-b.__dt));
  return byMonth;
}
function _mm_lowBalancesForMonth(days, payDay){
  if(!days || !days.length) return {baseLow: 0, prePayLow: 0, postPayLow: 0};
  let baseLow = Infinity, prePayLow = Infinity, postPayLow = Infinity;
  days.forEach(o=>{
    const bal = Number(o.balance);
    if(Number.isFinite(bal)) baseLow = Math.min(baseLow, bal);
    const day = o.__dt.getDate();
    if(day < payDay){
      if(Number.isFinite(bal)) prePayLow = Math.min(prePayLow, bal);
    }else{
      if(Number.isFinite(bal)) postPayLow = Math.min(postPayLow, bal);
    }
  });
  if(!Number.isFinite(baseLow)) baseLow = 0;
  if(!Number.isFinite(prePayLow)) prePayLow = baseLow;
  if(!Number.isFinite(postPayLow)) postPayLow = baseLow;
  return {baseLow, prePayLow, postPayLow};
}
function computeSweepPreview(){
  // Iterative sweep preview (matches computeSweepExtrasFromForecast):
  // Month-by-month: compute safe extra, then apply it to subsequent balances before next month.
  try{
    const rowsSrc = _mm_getDailyBalances();
    if(!Array.isArray(rowsSrc) || !rowsSrc.length) return [];

    const payDay = Number((debtPlan && debtPlan.payDay) || _mm_getDebtPlanPaymentDay() || 1) || 1;
    const buffer = Number(document.getElementById('debtBufferSelect')?.value || 0);

    const rows = rowsSrc
      .map(r=>{
        const d = r.date instanceof Date ? r.date : new Date(r.date);
        return { ...r, __dt: d, __bal: Number(r.balance) };
      })
      .filter(r=>r.__dt && !isNaN(r.__dt.getTime()) && isFinite(r.__bal))
      .sort((a,b)=>a.__dt - b.__dt);

    if(!rows.length) return [];

    // Month keys in order
    const monthKeys = [];
    const seen = new Set();
    rows.forEach(r=>{
      const k = _mm_monthKey(r.__dt);
      if(!seen.has(k)){ seen.add(k); monthKeys.push(k); }
    });

    const keys = monthKeys.slice(0, 12);
    const out = [];

    function payDateForKey(key){
      const [yy, mm] = key.split('-').map(x=>parseInt(x,10));
      const dd = Math.max(1, Math.min(28, payDay));
      return new Date(yy, mm-1, dd);
    }

    for(const k of keys){
      const pd = payDateForKey(k);

      // Compute lows BEFORE applying this month's sweep
      let baseLow = Infinity;
      let prePayLow = Infinity;
      let postPayLow = Infinity;

      rows.forEach(r=>{
        if(_mm_monthKey(r.__dt) !== k) return;
        baseLow = Math.min(baseLow, r.__bal);
        if(r.__dt.getDate() < payDay) prePayLow = Math.min(prePayLow, r.__bal);
        else postPayLow = Math.min(postPayLow, r.__bal);
      });

      if(!isFinite(baseLow)) baseLow = 0;
      if(!isFinite(prePayLow)) prePayLow = baseLow;
      if(!isFinite(postPayLow)) postPayLow = baseLow;

      const limitingLow = postPayLow; // IMPORTANT
      const sweepExtra = Math.max(0, limitingLow - buffer);

      // Apply sweepExtra on/after pay date for lowAfter estimate
      if(sweepExtra > 0){
        rows.forEach(r=>{
          if(r.__dt >= pd) r.__bal -= sweepExtra;
        });
      }

      // Lows AFTER applying this month's sweep (for display)
      let lowAfter = Infinity;
      rows.forEach(r=>{
        if(_mm_monthKey(r.__dt) !== k) return;
        lowAfter = Math.min(lowAfter, r.__bal);
      });
      if(!isFinite(lowAfter)) lowAfter = baseLow;

      // label
      const [yy, mm] = k.split('-').map(x=>parseInt(x,10));
      const label = _mm_monthLabel(new Date(yy, mm-1, 1));

      out.push({ key:k, label, baseLow, buffer, sweepExtra, lowAfter });
    }

    return out;
  }catch(e){
    return [];
  }
}
function renderSweepPreview(){
  const body = document.getElementById('sweepPreviewBody');
  if(!body) return;
  const rows = computeSweepPreview();
  body.innerHTML = '';
  if(!rows.length){
    body.innerHTML = '<tr><td class="p-2 text-gray-500" colspan="5">Run a forecast to see the sweep preview.</td></tr>';
    return;
  }
  rows.forEach(r=>{
    const extra = Number(r.sweepExtra)||0;
    const lowAfter = Number(r.lowAfter)||0;
    const extraClass = (extra > 0) ? 'text-blue-700' : 'text-gray-500';
    const lowAfterClass = (lowAfter >= 0) ? 'text-green-700' : 'text-red-600';
    const tr = document.createElement('tr');
    tr.className = 'border-t';
    tr.innerHTML = `
      <td class="p-2 text-left">${r.label}</td>
      <td class="p-2 text-right">${money(r.baseLow)}</td>
      <td class="p-2 text-right">${money(r.buffer)}</td>
      <td class="p-2 text-right ${extraClass}">${money(extra)}</td>
      <td class="p-2 text-right ${lowAfterClass}">${money(lowAfter)}</td>
    `;
    body.appendChild(tr);
  });
}


function renderMiniBalanceStrip(){
  const strip = document.getElementById('miniBalanceStrip');
  if(!strip) return;
  const rows = computeSweepPreview();
  strip.innerHTML = '';
  if(!rows.length) return;

  const sweepOn = !!document.getElementById('sweepModeToggle')?.checked;

  const vals = [];
  rows.forEach(r=>{
    vals.push(Number(r.baseLow)||0);
    vals.push(Number(r.lowAfter)||0);
  });
  const minV = Math.min(...vals);
  const maxV = Math.max(...vals);
  const range = (maxV - minV) || 1;

  rows.forEach(r=>{
    const base = Number(r.baseLow)||0;
    const after = Number(r.lowAfter)||0;

    const baseH = clamp(((base - minV)/range)*100, 4, 100);
    const afterH = clamp(((after - minV)/range)*100, 4, 100);

    const col = document.createElement('div');
    col.className = 'w-6 flex flex-col items-center';
    col.title = `${r.label}\nBase low: ${money(base)}${sweepOn ? `\nAfter sweep: ${money(after)}\nExtra: ${money(r.sweepExtra)}` : ''}`;

    const stack = document.createElement('div');
    stack.className = 'relative w-4 flex flex-col justify-end';
    stack.style.height = '40px';

    const baseBar = document.createElement('div');
    baseBar.className = 'w-4 rounded-sm bg-green-500';
    baseBar.style.height = `${baseH}%`;

    stack.appendChild(baseBar);

    if(sweepOn){
      const afterBar = document.createElement('div');
      afterBar.className = 'w-4 rounded-sm bg-green-900 opacity-80 absolute bottom-0';
      afterBar.style.height = `${afterH}%`;
      stack.appendChild(afterBar);
    }
    strip.appendChild(col);
  });
  try{ renderMiniBalanceLabels(rows.map(r=>String(r.label||'').trim())); }catch(e){}
}

// Wrap renderDebtPlanner so preview stays in sync without editing the original function body
(function(){
  const _rdp = window.renderDebtPlanner;
  if(typeof _rdp !== 'function' || _rdp._mm_sweepWrapped) return;
  function wrapped(){
    const res = _rdp.apply(this, arguments);
    try{ renderSweepPreview(); }catch(e){}
    try{ renderMiniBalanceStrip(); }catch(e){}
    return res;
  }
  wrapped._mm_sweepWrapped = true;
  window.renderDebtPlanner = wrapped;
})();

// Also refresh when buffer, pay day, or sweep toggle changes
document.addEventListener('DOMContentLoaded', function(){
  const buf = document.getElementById('debtBufferSelect');
  const pay = document.getElementById('debtPlanPayDay');
  const sw  = document.getElementById('sweepModeToggle');
  [buf,pay,sw].forEach(el=>{
    if(!el) return;
    el.addEventListener('change', ()=>{ try{ renderSweepPreview(); renderMiniBalanceStrip(); }catch(e){} });
    el.addEventListener('input',  ()=>{ try{ renderSweepPreview(); renderMiniBalanceStrip(); }catch(e){} });
  });
});

function formatRecurrence(recurrence, n){
  if(recurrence === 'once' || !recurrence) return 'once';
  const nn = Math.max(1, parseInt(n||1,10));
  if(recurrence === 'every_n_month') return `every ${nn} month${nn>1?'s':''}`;
  if(recurrence === 'every_n_week')  return `every ${nn} week${nn>1?'s':''}`;
  return String(recurrence);
}

// ---------- Menu / Tabs ----------
function toggleMenu(forceClose=false){
  const menu = document.getElementById('sideMenu');
  const backdrop = document.getElementById('menuBackdrop');
  const isOpen = menu && !menu.classList.contains('-translate-x-full');
  const shouldClose = forceClose || isOpen;

  if(!menu || !backdrop) return;

  if(shouldClose){
    menu.classList.add('-translate-x-full');
    backdrop.classList.add('hidden');
  }else{
    menu.classList.remove('-translate-x-full');
    backdrop.classList.remove('hidden');
  }
}
function showTab(tab){
  const tabs = ['dashboard','incomeTab','billsTab','accountsTab','calendarTab','multiMonthTab','debtPlannerTab','backupTab'];
  tabs.forEach(id=>{
    const el = document.getElementById(id);
    if(el) el.classList.add('hidden');
  });
  const target = document.getElementById(tab);
  if(target) target.classList.remove('hidden');

  // Sidebar active highlight
  try{
    document.querySelectorAll('.side-link').forEach(b=>b.classList.remove('active'));
    const btn = document.querySelector(`.side-link[data-tab="${tab}"]`);
    if(btn) btn.classList.add('active');
  }catch(e){}

  // refresh tabs when opened
  if(tab === 'accountsTab') renderAccounts();
  renderBillsPage();
if(tab === 'debtPlannerTab') renderDebtPlanner();
  if(tab === 'billsTab') renderBillsPage();
  if(tab === 'dashboard') renderMonthlyForecastChart();
}

// ---------- Profiles ----------
const PROFILES_KEY = 'moneyMapProfiles';
const ACTIVE_PROFILE_KEY = 'moneyMapActiveProfileId';
const LEGACY_DATA_KEY = 'moneyForecastData'; // legacy single-profile key (older versions)

function profileDataKey(id){ return `moneyMapProfileData:${id}`; }

function getProfiles(){
  try{ return JSON.parse(localStorage.getItem(PROFILES_KEY) || '[]') || []; }catch(e){ return []; }
}
function setProfiles(list){
  localStorage.setItem(PROFILES_KEY, JSON.stringify(list || []));
}
function getActiveProfileId(){
  return localStorage.getItem(ACTIVE_PROFILE_KEY) || '';
}
function setActiveProfileId(id){
  localStorage.setItem(ACTIVE_PROFILE_KEY, id);
}
function uuidProfile(){
  return 'p_' + Math.random().toString(36).slice(2,10) + Date.now().toString(36);
}

function ensureProfilesMigration(){
  // Goal:
  // 1) If profiles exist, do NOT overwrite them.
  // 2) If legacy single-profile data exists (moneyForecastData) and the active profile has no data yet,
  //    migrate it so users don't "lose" their existing data after upgrading.
  const profiles = getProfiles();
  let activeId = getActiveProfileId();

  // If there are existing profiles, just ensure an active profile is selected.
  if(profiles.length){
    if(!activeId){
      activeId = profiles[0].id;
      setActiveProfileId(activeId);
    }

    // Opportunistic legacy migration (safe, non-destructive):
    // If legacy data exists AND there's no data stored for the active profile yet, copy legacy -> active.
    try{
      const legacyRaw = localStorage.getItem(LEGACY_DATA_KEY);
      const hasProfileData = !!localStorage.getItem(profileDataKey(activeId));
      if(legacyRaw && !hasProfileData){
        localStorage.setItem(profileDataKey(activeId), legacyRaw);
      }
    }catch(e){}
    return;
  }

  // No profiles yet: create Default and migrate legacy if present.
  const id = uuidProfile();
  const now = new Date().toISOString();
  const defaultProfile = {id, name:'Default', createdAt: now};

  let legacyRaw = null;
  try{ legacyRaw = localStorage.getItem(LEGACY_DATA_KEY); }catch(e){}

  setProfiles([defaultProfile]);
  setActiveProfileId(id);

  if(legacyRaw){
    try{
      localStorage.setItem(profileDataKey(id), legacyRaw);
    }catch(e){}
  }
}
// ---------- Data Recovery (scan all localStorage keys) ----------
function scoreSavedData(obj){
  if(!obj || typeof obj !== 'object') return 0;
  const a = Array.isArray(obj.accounts) ? obj.accounts.length : 0;
  const i = Array.isArray(obj.incomes) ? obj.incomes.length : 0;
  const e = Array.isArray(obj.expenses) ? obj.expenses.length : 0;
  const d = Array.isArray(obj.debts) ? obj.debts.length : 0;
  const b = Math.abs(parseFloat(obj.balance)||0) > 0 ? 1 : 0;
  // weights favor having transactions
  return (a*2) + (i*3) + (e*3) + (d*2) + (b*1);
}

function tryParseJSON(raw){
  try{ return JSON.parse(raw||'{}') || {}; }catch(e){ return null; }
}

function rebuildProfilesFromStorageKeys(){
  const keys = Object.keys(localStorage||{});
  const ids = keys
    .filter(k=>k.startsWith('moneyMapProfileData:'))
    .map(k=>k.split(':').slice(1).join(':'))
    .filter(Boolean);
  if(!ids.length) return false;

  const existing = getProfiles();
  const now = new Date().toISOString();
  const merged = [...existing];

  ids.forEach(id=>{
    if(!merged.some(p=>p.id===id)){
      merged.push({id, name:`Recovered ${id.slice(-4)}`, createdAt: now});
    }
  });

  if(merged.length){
    setProfiles(merged);
    if(!getActiveProfileId()) setActiveProfileId(merged[0].id);
    return true;
  }
  return false;
}

function autoRecoverIfBlank(){
  // If current profile already has meaningful data, do nothing
  const activeId = getActiveProfileId();
  const activeKey = activeId ? profileDataKey(activeId) : '';
  const activeRaw = activeKey ? (localStorage.getItem(activeKey)||'') : '';
  const activeObj = tryParseJSON(activeRaw);
  if(activeObj && scoreSavedData(activeObj) > 0) return;

  // If profiles list got wiped but per-profile data still exists, rebuild it first
  const profiles = getProfiles();
  if(!profiles.length){
    rebuildProfilesFromStorageKeys();
  }

  // Re-check active after rebuild
  const activeId2 = getActiveProfileId();
  const activeKey2 = activeId2 ? profileDataKey(activeId2) : '';
  const activeObj2 = tryParseJSON(activeKey2 ? (localStorage.getItem(activeKey2)||'') : '');
  if(activeObj2 && scoreSavedData(activeObj2) > 0) return;

  // Scan all keys for candidate datasets
  const keys = Object.keys(localStorage||{});
  const candidates = [];

  keys.forEach(k=>{
    if(
      k === LEGACY_DATA_KEY ||
      k.startsWith('moneyMapProfileData:') ||
      k.includes('moneyForecastData') ||
      k.includes('moneyMapProfileData') ||
      k.includes('moneyMapData')
    ){
      const raw = localStorage.getItem(k);
      const obj = tryParseJSON(raw);
      if(obj){
        const score = scoreSavedData(obj);
        if(score > 0){
          candidates.push({k, raw, score, size: (raw||'').length});
        }
      }
    }
  });

  if(!candidates.length) return;

  // Pick best by score then size
  candidates.sort((a,b)=> (b.score - a.score) || (b.size - a.size));
  const best = candidates[0];

  // If best is an existing profile key, switch to that profile
  if(best.k.startsWith('moneyMapProfileData:')){
    const id = best.k.split(':').slice(1).join(':');
    const now = new Date().toISOString();
    const list = getProfiles();
    if(!list.some(p=>p.id===id)){
      list.push({id, name:`Recovered ${id.slice(-4)}`, createdAt: now});
      setProfiles(list);
    }
    setActiveProfileId(id);
    return;
  }

  // Otherwise, copy best data into active profile key (create profile if needed)
  let id = getActiveProfileId();
  if(!id){
    id = uuidProfile();
    const now = new Date().toISOString();
    setProfiles([{id, name:'Recovered', createdAt: now}]);
    setActiveProfileId(id);
  }
  try{ localStorage.setItem(profileDataKey(id), best.raw); }catch(e){}
}

function loadProfileSelectUI(){
  const sel = document.getElementById('profileSelect');
  if(!sel) return;
  const profiles = getProfiles();
  const activeId = getActiveProfileId();
  sel.innerHTML = '';
  profiles.forEach(p=>{
    const opt=document.createElement('option');
    opt.value=p.id;
    opt.textContent=p.name;
    sel.appendChild(opt);
  });
  if(activeId) sel.value = activeId;
}

function openProfileModal(){
  loadProfileSelectUI();
  const profiles = getProfiles();
  const activeId = getActiveProfileId();
  const active = profiles.find(p=>p.id===activeId) || profiles[0];
  const nameEl = document.getElementById('activeProfileName');
  if(nameEl) nameEl.textContent = active ? active.name : '';
  const m = document.getElementById('profileModal');
  if(m){ m.classList.remove('hidden'); m.classList.add('flex'); }
}
function closeProfileModal(){
  const m = document.getElementById('profileModal');
  if(m){ m.classList.add('hidden'); m.classList.remove('flex'); }
}

function createProfile(){
  const input = document.getElementById('newProfileName');
  const name = (input && input.value || '').trim();
  if(!name){ alert('Enter a profile name'); return; }

  const profiles = getProfiles();
  const id = uuidProfile();
  profiles.push({id, name, createdAt: new Date().toISOString()});
  setProfiles(profiles);

  // New profile should start EMPTY (duplicate is a separate action)
  const emptyDebtPlan = { strategy:'avalanche', extraMonthly:0, applyToForecast:false, payDay:1, plans:{} };
  const payload = JSON.stringify({
    balance: 0,
    accounts: [],
    incomes: [],
    expenses: [],
    debts: [],
    debtPlan: emptyDebtPlan,
    billCategories: billCategories // keep category list (user can edit)
  });

  try{ localStorage.setItem(profileDataKey(id), payload); }catch(e){}

  if(input) input.value = '';

  // Switch to the new profile immediately
  setActiveProfileId(id);
  loadProfileSelectUI();
  closeProfileModal();
  loadData();
  
try{ syncLinkedCreditCardDebtBalances(); saveData(); }catch(e){}computeForecast();
  renderDashboard();
  renderCalendar();
  renderMultiMonth();
  renderMonthlyForecastChart();
  renderBillsPage();
renderAccounts();
  renderDebtPlanner();
}

function renameActiveProfile(){
  const profiles = getProfiles();
  const activeId = getActiveProfileId();
  const p = profiles.find(x=>x.id===activeId);
  if(!p) return;
  const name = prompt('New name', p.name);
  if(!name) return;
  p.name = name.trim();
  setProfiles(profiles);
  loadProfileSelectUI();
  openProfileModal();
}

function duplicateActiveProfile(){
  const profiles = getProfiles();
  const activeId = getActiveProfileId();
  const p = profiles.find(x=>x.id===activeId);
  if(!p) return;
  const newName = prompt('Name for duplicated profile', p.name + ' Copy');
  if(!newName) return;

  const id = uuidProfile();
  profiles.push({id, name: newName.trim(), createdAt: new Date().toISOString()});
  setProfiles(profiles);

  try{
    const blob = localStorage.getItem(profileDataKey(activeId)) || '{}';
    localStorage.setItem(profileDataKey(id), blob);
  }catch(e){}

  loadProfileSelectUI();
}

function deleteActiveProfile(){
  const profiles = getProfiles();
  if(profiles.length<=1){ alert('You need at least one profile.'); return; }
  const activeId = getActiveProfileId();
  const p = profiles.find(x=>x.id===activeId);
  if(!p) return;
  if(!confirm(`Delete profile "${p.name}"? This cannot be undone.`)) return;

  try{ localStorage.removeItem(profileDataKey(activeId)); }catch(e){}

  const remaining = profiles.filter(x=>x.id!==activeId);
  setProfiles(remaining);
  setActiveProfileId(remaining[0].id);

  loadProfileSelectUI();
  closeProfileModal();
  loadData();
  computeForecast();
  renderDashboard();
  renderCalendar();
  renderMultiMonth();
  renderMonthlyForecastChart();
  renderBillsPage();
renderAccounts();
  renderDebtPlanner();
}

function switchProfile(id){
  if(!id) return;
  saveData();
  setActiveProfileId(id);

  loadData();
  computeForecast();
  renderDashboard();
  renderCalendar();
  renderMultiMonth();
  renderMonthlyForecastChart();
  renderBillsPage();
renderAccounts();
  renderDebtPlanner();
}

// ---------- Storage ----------
function saveData(){
  try{
    const payload = { currentBalance, accounts, incomes, expenses, debts, debtPlan, billCategories, paidOccurrences };
    localStorage.setItem(profileDataKey(getActiveProfileId()), JSON.stringify(payload));
  }catch(e){
    console.error('saveData failed', e);
  }
}
function loadData(){
  let saved = {};
  try{ saved = JSON.parse(localStorage.getItem(profileDataKey(getActiveProfileId()))||'{}') || {}; }
  catch(e){ saved = {}; }
  currentBalance = parseFloat(saved.balance)||0;
  accounts = saved.accounts || [];
  incomes = saved.incomes || [];
  expenses = saved.expenses || [];
  // Backfill enabled flag for bills
  expenses.forEach(e=>{ if(e && !('enabled' in e)) e.enabled = true; });
  debts = saved.debts || [];
  billCategories = saved.billCategories || [{id:'uncat', name:'Uncategorized'}];
  paidOccurrences = saved.paidOccurrences || {};
  debtPlan = saved.debtPlan || debtPlan;
  if(!debtPlan.payDay) debtPlan.payDay = 1;

  // Ensure at least one debit account exists so dropdowns work
  if(!accounts.some(a=>a.type==='debit')){
    const defaultDebit = {id: uuid(), name: 'Checking', type:'debit'};
    accounts.unshift(defaultDebit);
  }

  // Backfill account currentBalance (new feature)
  accounts.forEach(a=>{
    if(!('currentBalance' in a)) a.currentBalance = 0;
  });
  // If legacy "Current Balance" exists but accounts are all zero, seed the first debit account
  try{
    const debits = accounts.filter(a=>a.type==='debit');
    const allZero = debits.length && debits.every(a=>!isFinite(+a.currentBalance) || (+a.currentBalance===0));
    if(allZero && isFinite(+currentBalance) && +currentBalance!==0){
      debits[0].currentBalance = +currentBalance;
    }
  }catch(e){}
  // Backfill older items that didn't have these fields
  // Ensure all items have ids (needed for generated debt plan expenses)
  incomes.forEach(i=>{ if(!i.id) i.id = uuid(); });
  expenses.forEach(e=>{
    if(e && e.enabled === false) return; if(!e.id) e.id = uuid(); });
  debts.forEach((d, idx)=>{ if(!d.id) d.id = uuid(); if(typeof d.order !== 'number') d.order = idx; });

  incomes.forEach(i=>{
    if(!('accountId' in i)) i.accountId = (accounts.find(a=>a.type==='debit')||accounts[0]).id;
  });
  expenses.forEach(e=>{
    if(e && e.enabled === false) return;
    if(!('payMethod' in e)) e.payMethod = 'debit';
    if(!('debitAccountId' in e)) e.debitAccountId = (accounts.find(a=>a.type==='debit')||accounts[0]).id;
    if(!('creditAccountId' in e)) e.creditAccountId = (accounts.find(a=>a.type==='credit')||{}).id || null;
  });

  // Ensure default category exists
  if(!Array.isArray(billCategories) || billCategories.length===0){
    billCategories = [{id:'uncat', name:'Uncategorized'}];
  }
  if(!billCategories.some(c=>c.id==='uncat')){
    billCategories.unshift({id:'uncat', name:'Uncategorized'});
  }

  // Backfill older expenses without category
  expenses.forEach(e=>{
    if(e && e.enabled === false) return;
    if(!('categoryId' in e) || !e.categoryId) e.categoryId = 'uncat';
    // If category was deleted, fallback
    if(!billCategories.some(c=>c.id===e.categoryId)) e.categoryId = 'uncat';
  });

  document.getElementById('balance').value = currentBalance;
}

// ---------- Export / Import ----------
function exportData(){
  try{
    const payload = {
      version: 1,
      exportedAt: new Date().toISOString(),
      profileId: getActiveProfileId(),
      data: {
        balance: currentBalance,
        accounts, incomes, expenses, debts, debtPlan, billCategories
      }
    };

    const pad = (n)=>String(n).padStart(2,'0');
    const d = new Date();
    const filename = `money-map-backup-${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}_${pad(d.getHours())}-${pad(d.getMinutes())}-${pad(d.getSeconds())}.json`;

    const blob = new Blob([JSON.stringify(payload, null, 2)], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }catch(e){
    alert('Export failed: ' + (e.message||e));
  }
}

let __pendingImportObject = null;

function importData(evt){
  const input = evt.target;
  const file = input.files && input.files[0];
  if(!file) return;

  const reader = new FileReader();
  reader.onload = ()=>{
    try{
      const obj = JSON.parse(reader.result);
      if(!obj || typeof obj !== 'object' || !obj.data){
        throw new Error('Invalid backup file.');
      }
      __pendingImportObject = obj;
      openImportConfirm();
    }catch(e){
      alert('Import failed: ' + (e.message||e));
      __pendingImportObject = null;
      input.value = '';
    }
  };
  reader.readAsText(file);
}

function openImportConfirm(){
  const m = document.getElementById('importConfirmModal');
  if(m) m.classList.remove('hidden');
}

function closeImportConfirm(){
  const m = document.getElementById('importConfirmModal');
  if(m) m.classList.add('hidden');
  const input = document.getElementById('backupImportInput');
  if(input) input.value = '';
  __pendingImportObject = null;
}

function confirmImportOverwrite(){
  if(!__pendingImportObject) return closeImportConfirm();
  try{
    const d = __pendingImportObject.data;

    currentBalance = Number(d.balance || 0);
    accounts = Array.isArray(d.accounts) ? d.accounts : [];
    incomes  = Array.isArray(d.incomes)  ? d.incomes  : [];
    expenses = Array.isArray(d.expenses) ? d.expenses : [];
    debts    = Array.isArray(d.debts)    ? d.debts    : [];
    debtPlan = (d.debtPlan && typeof d.debtPlan === 'object') ? d.debtPlan : debtPlan;
    billCategories = Array.isArray(d.billCategories) ? d.billCategories : [];

    saveData();
    computeForecast();
    renderDashboard();
    renderMonthlyForecastChart();
    renderCalendar();
    renderMultiMonth();
    renderBillsPage();
renderDebtPlanner();

    closeImportConfirm();
    alert('Import complete.');
  }catch(e){
    alert('Import failed: ' + (e.message||e));
    closeImportConfirm();
  }
}

// ---------- Bill Categories ----------
function ensureCategories(){
  // Default categories (with colors)
  const defaults = [
    {id:'uncat', name:'Uncategorized', color:'#9CA3AF'},
    {id:'essential', name:'Essential', color:'#2563EB'},      // blue
    {id:'luxury', name:'Luxury', color:'#F59E0B'},            // amber
    {id:'groceries', name:'Groceries', color:'#22C55E'},      // green
    {id:'entertainment', name:'Entertainment', color:'#A855F7'} // purple
  ];

  if(!Array.isArray(billCategories) || billCategories.length===0){
    billCategories = defaults.slice();
    return;
  }

  // Backfill missing color fields
  billCategories.forEach(c=>{
    const d = defaults.find(x=>x.id===c.id);
    if(d && !c.color) c.color = d.color;
    if(!c.color) c.color = '#9CA3AF';
  });

  // Ensure all defaults exist (preserve user's edits if already present)
  defaults.forEach(d=>{
    if(!billCategories.some(c=>c.id===d.id)){
      billCategories.push({...d});
    }
  });

  // Ensure Uncategorized is first
  if(!billCategories.some(c=>c.id==='uncat')){
    billCategories.unshift({id:'uncat', name:'Uncategorized', color:'#9CA3AF'});
  }else{
    billCategories = [
      billCategories.find(c=>c.id==='uncat'),
      ...billCategories.filter(c=>c.id!=='uncat')
    ];
  }
}

function ensureBillCategory(id, name){
  billCategories = billCategories || [{id:'uncat', name:'Uncategorized'}];
  const exists = billCategories.find(c=>c.id===id);
  if(exists) return id;
  billCategories.push({id, name});
  return id;
}

function getCategoryNameById(id){
  ensureCategories();
  const c = billCategories.find(x=>x.id===id);
  return c ? c.name : 'Uncategorized';
}

function populateCategorySelect(selectEl, selectedId){
  if(!selectEl) return;
  ensureCategories();
  selectEl.innerHTML = '';
  billCategories.forEach(c=>{
    const opt=document.createElement('option');
    opt.value=c.id;
    opt.textContent=c.name;
    selectEl.appendChild(opt);
  });
  selectEl.value = selectedId && billCategories.some(c=>c.id===selectedId) ? selectedId : 'uncat';
}

function openCategoryModal(){
  ensureCategories();
  renderCategoryList();
  const modal=document.getElementById('categoryModal');
  modal.classList.remove('hidden');
  modal.classList.add('flex');
  const input=document.getElementById('newCategoryName');
  if(input){ input.value=''; setTimeout(()=>input.focus(), 0); }
}

function closeCategoryModal(){
  const modal=document.getElementById('categoryModal');
  modal.classList.add('hidden');
  modal.classList.remove('flex');
  // Refresh category select in case user is editing a bill right now
  const sel=document.getElementById('expenseCategory');
  if(sel && currentItem && currentItem.type==='expense'){
    const item = currentItem.isNew ? (currentItem.draft||{}) : (expenses[currentItem.index]||{});
    populateCategorySelect(sel, item.categoryId || 'uncat');
  }
  saveData();
  renderDashboard();
  computeForecast();
}

 // ---------- Paid Occurrences (per profile) ----------
function paidKey(date, expenseId){
  return `${formatDate(date)}|${expenseId}`;
}
function isPaidOccurrence(date, expenseId){
  try{
    return !!paidOccurrences[paidKey(date, expenseId)];
  }catch(e){ return false; }
}
function setPaidOccurrence(date, expenseId, isPaid){
  const k = paidKey(date, expenseId);
  if(isPaid) paidOccurrences[k] = true;
  else delete paidOccurrences[k];
  saveData();
}
// Global helpers for checkbox handlers
window.markPaidOccurrence = function(date, expenseId){ setPaidOccurrence(date, expenseId, true); };
window.unmarkPaidOccurrence = function(date, expenseId){ setPaidOccurrence(date, expenseId, false); };


// Ensure helpers are globally available even across multiple <script> tags
// Backward-compatible helpers (used by some checkbox handlers)
function markPaidOccurrence(date, expenseId){
  setPaidOccurrence(date, expenseId, true);
}
function unmarkPaidOccurrence(date, expenseId){
  setPaidOccurrence(date, expenseId, false);
}
function renderCategoryList(){
  ensureCategories();
  const list=document.getElementById('categoryList');
  if(!list) return;
  list.innerHTML='';

  billCategories.forEach(c=>{
    const row=document.createElement('div');
    row.className='p-2 border rounded bg-white';

    const top=document.createElement('div');
    top.className='flex items-center justify-between gap-2';

    const nameInput=document.createElement('input');
    nameInput.className='flex-1 p-2 border rounded text-sm';
    nameInput.value = c.name || '';
    nameInput.disabled = (c.id==='uncat'); // keep default name stable
    nameInput.title = (c.id==='uncat') ? 'Uncategorized is always available' : 'Edit category name';

    const colorInput=document.createElement('input');
    colorInput.type='color';
    colorInput.className='w-10 h-10 p-0 border rounded';
    colorInput.value = c.color || '#9CA3AF';
    colorInput.disabled = (c.id==='uncat');

    top.appendChild(nameInput);
    top.appendChild(colorInput);

    const actions=document.createElement('div');
    actions.className='flex items-center gap-2';

    const delBtn=document.createElement('button');
    delBtn.className='px-3 py-2 rounded border text-sm';
    delBtn.textContent = (c.id==='uncat') ? 'Default' : 'Delete';
    delBtn.disabled = (c.id==='uncat');
    delBtn.onclick = ()=>{ if(c.id!=='uncat') deleteCategory(c.id); };

    actions.appendChild(delBtn);
    top.appendChild(actions);

    const hint=document.createElement('div');
    hint.className='text-xs text-gray-500 mt-2';
    hint.textContent = (c.id==='uncat') ? 'Default category' : 'Changes apply across your bills immediately.';

    // Persist edits (name + color)
    const persist = ()=>{
      if(c.id==='uncat') return;
      const nextName = (nameInput.value||'').trim();
      if(!nextName){ nameInput.value = c.name; return; }
      // Prevent duplicates (case-insensitive) excluding self
      if(billCategories.some(x=>x.id!==c.id && (x.name||'').toLowerCase()===nextName.toLowerCase())){
        nameInput.value = c.name;
        return;
      }
      c.name = nextName;
      c.color = colorInput.value || c.color || '#9CA3AF';
      saveData();
      // Refresh visuals that depend on categories
      renderBillsPage();
updateBillsMonthOptions();
    };

    nameInput.addEventListener('blur', persist);
    nameInput.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); nameInput.blur(); }});
    colorInput.addEventListener('change', persist);

    row.appendChild(top);
    row.appendChild(hint);
    list.appendChild(row);
  });
}

function addCategory(){
  ensureCategories();
  const input=document.getElementById('newCategoryName');
  const name=(input?.value||'').trim();
  if(!name) return;
  // Prevent duplicates (case-insensitive)
  if(billCategories.some(c=>c.name.toLowerCase()===name.toLowerCase())) return;
  billCategories.push({id: uuid(), name});
  renderCategoryList();
  if(input){ input.value=''; input.focus(); }
  saveData();
}

function deleteCategory(catId){
  if(!catId || catId==='uncat') return;
  // Reassign any bills using this category back to Uncategorized
  expenses.forEach(e=>{
    if(e && e.enabled === false) return; if(e.categoryId===catId) e.categoryId='uncat'; });
  billCategories = billCategories.filter(c=>c.id!==catId);
  ensureCategories();
  renderCategoryList();
  saveData();
}

// ---------- Dashboard ----------
function renderDashboard(){
  const incomeList=document.getElementById('incomeList');
  incomeList.innerHTML='';
  incomes.forEach((i,index)=>{
    const div=document.createElement('div');
    div.className='p-2 border rounded cursor-pointer bg-white';
    div.textContent=`${i.name} (${money(i.amount)})`;
    div.onclick=()=>openItemModal('income',index);
    incomeList.appendChild(div);
  });

  // Update today's forecast box (today always equals current balance per app rules)
  const balEl = document.getElementById('todayForecastBalance');
  const dateEl = document.getElementById('todayForecastDate');
  renderMonthlyForecastChart();

  if(balEl){
    const cb = getTotalDebitCash();
    balEl.textContent = money(cb);

    const deltaEl=document.getElementById('forecastDelta12mo');
    const bal12El=document.getElementById('forecastBalance12mo');
    const monthsArr = Array.isArray(multiMonthData) ? multiMonthData : [];
    const m12 = monthsArr.length ? monthsArr[Math.min(11, monthsArr.length-1)] : null;
    const bal12 = m12 ? (Number(m12.balance)||0) : 0;
    if(bal12El) bal12El.textContent = money(bal12);
    if(deltaEl) deltaEl.textContent = money(bal12 - cb);
  }
  if(dateEl){
    const t = new Date();
    dateEl.textContent = t.toLocaleDateString(undefined,{weekday:'long', year:'numeric', month:'long', day:'numeric'});
  }
  renderDashboardBalanceInputs();
}


// ---------- Dashboard Balances (Accounts + Debts) ----------
function getTotalDebitCash(){
  try{
    return getDebitAccounts().reduce((s,a)=>s + (parseFloat(a.currentBalance)||0), 0);
  }catch(e){ return parseFloat(document.getElementById('balance')?.value)||currentBalance||0; }
}

function renderDashboardBalanceInputs(){
  const accWrap = document.getElementById('dashboardAccountBalances');
  const debtWrap = document.getElementById('dashboardDebtBalances');
  const totalEl = document.getElementById('dashboardTotalCash');
  if(!accWrap) return;

  accWrap.innerHTML = '';
  if(debtWrap) debtWrap.innerHTML = '';

  const allAccounts = [...getDebitAccounts(), ...getCreditAccounts()];
  if(allAccounts.length===0){
    accWrap.innerHTML = `<div class="text-xs text-gray-500">No accounts yet. Add accounts in the Accounts tab.</div>`;
  } else {
    allAccounts.forEach(a=>{
      const row = document.createElement('div');
      row.className = 'flex items-center gap-3 p-2 border rounded-lg bg-white';
      row.innerHTML = `
        <div class="flex-1">
          <div class="text-sm font-semibold">${a.name || 'Account'}</div>
          <div class="text-xs text-gray-500">${a.type==='credit'?'Credit Card':'Debit / Checking'}</div>
        </div>

        ${a.type==='credit' ? `
          <div class="flex flex-col items-end gap-1">
            <div class="text-[11px] text-gray-500">Current balance</div>
            <input id="dash_accbal_${a.id}" type="number" inputmode="decimal" class="w-36 p-2 border rounded text-right"
                   value="${(a.currentBalance!=null?a.currentBalance:0)}"
                   oninput="onDashboardBalancesChanged()" />
            <div class="text-[11px] text-gray-500 mt-1">Last statement</div>
            <input id="dash_ccstmt_${a.id}" type="number" inputmode="decimal" class="w-36 p-2 border rounded text-right"
                   value="${(a.lastStatementBalance!=null?a.lastStatementBalance:0)}"
                   oninput="onDashboardBalancesChanged()" />
          </div>
        ` : `
          <div class="flex flex-col items-end gap-1">
            <div class="text-[11px] text-gray-500">Current balance</div>
            <input id="dash_accbal_${a.id}" type="number" inputmode="decimal" class="w-36 p-2 border rounded text-right"
                   value="${(a.currentBalance!=null?a.currentBalance:0)}"
                   oninput="onDashboardBalancesChanged()" />
          </div>
        `}
      `;accWrap.appendChild(row);
    });
  }

  if(debtWrap){
  if(debts.length===0){
    debtWrap.innerHTML = `<div class="text-xs text-gray-500">No debts yet. Add debts in the Debt Planner tab.</div>`;
  } else {
    debts.forEach(d=>{
      const row = document.createElement('div');
      row.className = 'flex items-center gap-3 p-2 border rounded-lg bg-white';
      row.innerHTML = `
        <div class="flex-1">
          <div class="text-sm font-semibold">${d.name || 'Debt'}</div>
          <div class="text-xs text-gray-500">${d.type==='loan'?'Loan':'Credit Card'} • Min: ${money(d.minPayment||0)}</div>
        </div>
        <input id="dash_debtbal_${d.id}" type="number" inputmode="decimal" class="w-36 p-2 border rounded text-right"
               value="${(d.balance!=null?d.balance:0)}"
               oninput="onDashboardBalancesChanged(true)" />
      `;
      debtWrap.appendChild(row);
    });
  }

  }

  // Sync hidden legacy balance input from debit accounts
  const totalCash = getTotalDebitCash();
  const balInput = document.getElementById('balance');
  if(balInput) balInput.value = totalCash;
  currentBalance = totalCash;
  if(totalEl) totalEl.textContent = money(totalCash);
}

function onDashboardBalancesChanged(){
  // Live-update totals and keep the hidden balance input synced
  let total = 0;
  try{
    getDebitAccounts().forEach(a=>{
      const el = document.getElementById('dash_accbal_'+a.id);
      const v = parseFloat(el?.value||'0')||0;
      total += v;
    });
  }catch(e){}
  const balInput = document.getElementById('balance');
  if(balInput) balInput.value = total;
  const totalEl = document.getElementById('dashboardTotalCash');
  if(totalEl) totalEl.textContent = money(total);

  // Sync dashboard inputs into account data immediately (so modals reflect the same values)
  try{
    (accounts||[]).forEach(a=>{
      const balEl = document.getElementById('dash_accbal_'+a.id);
      if(balEl){
        const v = parseFloat(balEl.value||'0')||0;
        if(isFinite(v)) a.currentBalance = v;
      }
      if(a && a.type==='credit'){
        const lsEl = document.getElementById('dash_ccstmt_'+a.id);
        if(lsEl){
          const lsV = parseFloat(lsEl.value||'0')||0;
          if(isFinite(lsV)) a.lastStatementBalance = lsV;
        }
      }
    });
  }catch(e){}


  try{ syncLinkedCreditCardDebtBalances(); }catch(e){}
}

function applyDashboardBalancesToData(){
  // Pull dashboard inputs -> persist to accounts/debts -> update legacy currentBalance
  let touched = false;

  accounts.forEach(a=>{
    const el = document.getElementById('dash_accbal_'+a.id);
    if(!el) return;
    const v = parseFloat(el.value||'0');
    a.currentBalance = isFinite(v) ? v : 0;
    touched = true;
  });

  debts.forEach(d=>{
    const el = document.getElementById('dash_debtbal_'+d.id);
    if(!el) return;
    const v = parseFloat(el.value||'0');
    d.balance = isFinite(v) ? v : 0;
    touched = true;
  });

  // Update legacy cash balance from debit accounts
  const totalCash = getTotalDebitCash();
  currentBalance = totalCash;
  const balInput = document.getElementById('balance');
  if(balInput) balInput.value = totalCash;

  if(touched){
    saveData();
  }
}

function syncDashboardBalancesFromModals(){
  // If user edited balances in modals, refresh dashboard view
  renderDashboardBalanceInputs();
}

// ---------- Accounts ----------
function getDebitAccounts(){ return accounts.filter(a=>a.type==='debit'); }
function getCreditAccounts(){ return accounts.filter(a=>a.type==='credit'); }
function accountName(id){
  return (accounts.find(a=>a.id===id)||{}).name || '—';
}

function renderAccounts(){
  const debitList = document.getElementById('debitAccountsList');
  const creditList = document.getElementById('creditAccountsList');
  debitList.innerHTML = '';
  creditList.innerHTML = '';

  getDebitAccounts().forEach((a, idx)=>{
    const div = document.createElement('div');
    div.className='p-3 border rounded-lg bg-gray-50 cursor-pointer';
    div.innerHTML = `<div class="font-semibold">${a.name}</div><div class="text-xs text-gray-500">Debit / Checking</div>`;
    div.onclick = ()=>openAccountModal(a.id);
    debitList.appendChild(div);
  });

  const credits = getCreditAccounts();
  if(credits.length === 0){
    const empty = document.createElement('div');
    empty.className='text-sm text-gray-500';
    empty.textContent='No credit cards yet. Tap “Add Account” to add one.';
    creditList.appendChild(empty);
  } else {
    credits.forEach(a=>{
      const div = document.createElement('div');
      div.className='p-3 border rounded-lg bg-gray-50 cursor-pointer';
      const due = clamp(parseInt(a.dueDay||1,10),1,28);
      div.innerHTML = `
        <div class="font-semibold">${a.name}</div>
        <div class="text-xs text-gray-500">Stmt close: ${clamp(parseInt((a.statementCloseDay!=null?a.statementCloseDay:due),10),1,28)} • Pays from: ${accountName(a.payFromAccountId)}</div>
      `;
      div.onclick = ()=>openAccountModal(a.id);
      creditList.appendChild(div);
    });
  }
}

function addAccount(){
  // Create a draft account but DO NOT persist until user clicks Save
  const id = uuid();
  const draft = {id, name:'New Account', type:'debit', currentBalance:0};
  currentAccount = {id, isNew:true};
  // Put draft in a temporary place (not in accounts array yet)
  window.__accountDraft = draft;

  // Populate modal fields from draft
  document.getElementById('accountName').value = draft.name;
  document.getElementById('accountType').value = draft.type;
  document.getElementById('accountCurrentBalance').value = (draft.currentBalance!=null?draft.currentBalance:0);

  // Populate payFrom dropdown (debit accounts that already exist)
  const payFromSel = document.getElementById('accountPayFrom');
  payFromSel.innerHTML = '';
  getDebitAccounts().forEach(d=>{
    const opt = document.createElement('option');
    opt.value = d.id;
    opt.textContent = d.name;
    payFromSel.appendChild(opt);
  });

  document.getElementById('accountDueDay').value = 1;
  if(getDebitAccounts()[0]) payFromSel.value = getDebitAccounts()[0].id;

  renderAccountModalFields();
  document.getElementById('accountModal').classList.remove('hidden');
}
function openAccountModal(accountId){
  currentAccount = {id: accountId, isNew:false};
  window.__accountDraft = null;
  const a = accounts.find(x=>x.id===accountId);
  if(!a) return;

  document.getElementById('accountName').value = a.name || '';
  document.getElementById('accountType').value = a.type || 'debit';
  document.getElementById('accountCurrentBalance').value = (a.currentBalance!=null?a.currentBalance:0);

  // populate debit accounts list for payFrom (exclude credit)
  const payFromSel = document.getElementById('accountPayFrom');
  payFromSel.innerHTML = '';
  getDebitAccounts().forEach(d=>{
    const opt = document.createElement('option');
    opt.value = d.id;
    opt.textContent = d.name;
    payFromSel.appendChild(opt);
  });

  document.getElementById('accountDueDay').value = clamp(parseInt(a.dueDay||1,10),1,28);
  document.getElementById('accountStatementCloseDay').value = clamp(parseInt((a.statementCloseDay!=null?a.statementCloseDay:(a.dueDay||1)),10),1,28);
  try{ const lsEl=document.getElementById('accountLastStatementBalance'); if(lsEl) lsEl.value = (a.lastStatementBalance!=null?a.lastStatementBalance:0); }catch(e){}
  if(a.payFromAccountId) payFromSel.value = a.payFromAccountId;
  else if(getDebitAccounts()[0]) payFromSel.value = getDebitAccounts()[0].id;

  renderAccountModalFields();
  document.getElementById('accountModal').classList.remove('hidden');
}
function renderAccountModalFields(){
  const type = document.getElementById('accountType').value;
  const creditFields = document.getElementById('creditFields');
  if(type === 'credit') creditFields.classList.remove('hidden');
  else creditFields.classList.add('hidden');
}
function closeAccountModal(){
  // If user cancels a NEW account, discard the draft
  if(currentAccount && currentAccount.isNew){
    window.__accountDraft = null;
  }
  currentAccount=null;
  document.getElementById('accountModal').classList.add('hidden');
}

function saveAccountModal(){
  if(!currentAccount) return;

  // If this is a NEW account, create it now from draft
  let a = accounts.find(x=>x.id===currentAccount.id);
  if(!a){
    if(currentAccount.isNew && window.__accountDraft && window.__accountDraft.id===currentAccount.id){
      a = {...window.__accountDraft};
      accounts.push(a);
      window.__accountDraft = null;
    } else {
      return;
    }
  }

  a.name = document.getElementById('accountName').value || 'Account';
  a.type = document.getElementById('accountType').value;

  a.currentBalance = parseFloat(document.getElementById('accountCurrentBalance').value)||0;

  if(a.type === 'credit'){
    a.dueDay = clamp(parseInt(document.getElementById('accountDueDay').value||'1',10),1,28);
    a.statementCloseDay = clamp(parseInt(document.getElementById('accountStatementCloseDay').value||String(a.dueDay||1),10),1,28);
    a.payFromAccountId = document.getElementById('accountPayFrom').value || (getDebitAccounts()[0]||{}).id || null;
  } else {
    delete a.dueDay;
    delete a.statementCloseDay;
    delete a.payFromAccountId;
  }

  // If user converted a credit account to debit (or deleted last debit), ensure at least one debit exists
  if(!accounts.some(x=>x.type==='debit')){
    accounts.unshift({id: uuid(), name:'Checking', type:'debit'});
  }

  saveData();
  
  try{ syncLinkedCreditCardDebtBalances(); saveData(); }catch(e){}
renderAccounts();
  renderBillsPage();
renderDashboard();
  closeAccountModal();
  computeForecast();
}
function deleteAccountModal(){
  if(!currentAccount) return;
  const id = currentAccount.id;

  // Don't allow deleting last debit account (keeps app stable)
  const isDebit = (accounts.find(a=>a.id===id)||{}).type === 'debit';
  if(isDebit && getDebitAccounts().length <= 1){
    alert('You need at least one debit/checking account.');
    return;
  }

  accounts = accounts.filter(a=>a.id!==id);

  // Clean up any items pointing to this account
  const fallbackDebitId = (getDebitAccounts()[0]||{}).id;
  incomes.forEach(i=>{
    if(i.accountId === id) i.accountId = fallbackDebitId;
  });
  expenses.forEach(e=>{
    if(e && e.enabled === false) return;
    if(e.debitAccountId === id) e.debitAccountId = fallbackDebitId;
    if(e.creditAccountId === id) e.creditAccountId = null;
  });

  saveData();
  renderAccounts();
  renderBillsPage();
renderDashboard();
  closeAccountModal();
  computeForecast();
}

// ---------- Add Items ----------
function buildNewIncome(){
  const debitId = (getDebitAccounts()[0]||{}).id || null;
  return {
    id: uuid(),
    name: 'New Income',
    amount: 0,
    date: new Date().toISOString().split('T')[0],
    recurrence: 'once',
    n: 1,
    accountId: debitId
  };
}
function buildNewExpense(){
  const debitId = (getDebitAccounts()[0]||{}).id || null;
  const creditId = (getCreditAccounts()[0]||{}).id || null;
  return {
    id: uuid(),
    name: 'New Bill',
    amount: 0,
    date: new Date().toISOString().split('T')[0],
    recurrence: 'once',
    n: 1,
    payMethod: 'debit',
    debitAccountId: debitId,
    creditAccountId: creditId,
    categoryId: 'uncat'
  };
}

function addIncome(){
  // Do NOT create the item until the user hits Save
  openItemModal('income', -1, buildNewIncome());
}
function addExpense(){
  // Do NOT create the item until the user hits Save
  openItemModal('expense', -1, buildNewExpense());
}

// ---------- Item Modal ----------

function openItemModal(type, index, draft){
  const isNew = (index === -1);
  currentItem = { type, index, isNew, draft: draft || null };
  const item = isNew ? (draft || (type==='income' ? buildNewIncome() : buildNewExpense()))
                     : (type==='income' ? incomes[index] : expenses[index]);

  // Hide delete button for new (unsaved) items
  const delBtn = document.getElementById('itemDeleteBtn');
  if(delBtn){ delBtn.style.display = isNew ? 'none' : 'inline-flex'; }

  document.getElementById('itemName').value=item.name;
  document.getElementById('itemAmount').value=item.amount;
  document.getElementById('itemDate').value=item.date;
  document.getElementById('itemRecurrence').value=item.recurrence;
  document.getElementById('itemN').value=item.n||1;

  // Populate dropdowns
  const itemAccountSel = document.getElementById('itemAccount');
  const expenseDebitSel = document.getElementById('expenseDebitAccount');
  const expenseCreditSel = document.getElementById('expenseCreditAccount');

  itemAccountSel.innerHTML = '';
  expenseDebitSel.innerHTML = '';
  expenseCreditSel.innerHTML = '';

  getDebitAccounts().forEach(a=>{
    const opt1 = document.createElement('option');
    opt1.value = a.id; opt1.textContent = a.name;
    itemAccountSel.appendChild(opt1);

    const opt2 = document.createElement('option');
    opt2.value = a.id; opt2.textContent = a.name;
    expenseDebitSel.appendChild(opt2);
  });
  getCreditAccounts().forEach(a=>{
    const opt = document.createElement('option');
    opt.value = a.id; opt.textContent = a.name;
    expenseCreditSel.appendChild(opt);
  });

  // Show relevant rows & set values
  document.getElementById('incomeAccountRow').classList.add('hidden');
  document.getElementById('expensePayRow').classList.add('hidden');
  document.getElementById('expenseCategoryRow').classList.add('hidden');
  document.getElementById('expenseDebitRow').classList.add('hidden');
  document.getElementById('expenseCreditRow').classList.add('hidden');

  if(type === 'income'){
    document.getElementById('incomeAccountRow').classList.remove('hidden');
    itemAccountSel.value = item.accountId || (getDebitAccounts()[0]||{}).id || '';
  } else {
    document.getElementById('expensePayRow').classList.remove('hidden');
    document.getElementById('expenseCategoryRow').classList.remove('hidden');
    populateCategorySelect(document.getElementById('expenseCategory'), item.categoryId || 'uncat');
    document.getElementById('expenseDebitRow').classList.remove('hidden');
    document.getElementById('expenseCreditRow').classList.remove('hidden');

    document.getElementById('expensePayMethod').value = item.payMethod || 'debit';
    expenseDebitSel.value = item.debitAccountId || (getDebitAccounts()[0]||{}).id || '';
    if(getCreditAccounts().length > 0){
      expenseCreditSel.value = item.creditAccountId || (getCreditAccounts()[0]||{}).id || '';
    } else {
      item.payMethod = 'debit';
      document.getElementById('expensePayMethod').value = 'debit';
    }
    renderItemModalAccountFields();
  }

  document.getElementById('itemModal').classList.remove('hidden');
}
function renderItemModalAccountFields(){
  // toggles debit/credit sub-select visibility
  const payMethod = document.getElementById('expensePayMethod').value;
  const creditRow = document.getElementById('expenseCreditRow');
  if(payMethod === 'credit' && getCreditAccounts().length > 0){
    creditRow.classList.remove('hidden');
  } else {
    creditRow.classList.add('hidden');
  }
}
function closeItemModal(){ currentItem=null; document.getElementById('itemModal').classList.add('hidden'); }

function saveItemModal(){
  if(!currentItem) return;

  const isNew = !!currentItem.isNew;
  // Use draft object for new items, otherwise edit existing
  const item = isNew ? (currentItem.draft || (currentItem.type==='income' ? buildNewIncome() : buildNewExpense()))
                     : (currentItem.type==='income' ? incomes[currentItem.index] : expenses[currentItem.index]);

  item.name = document.getElementById('itemName').value;
  item.amount = parseFloat(document.getElementById('itemAmount').value)||0;
  item.date = document.getElementById('itemDate').value;
  item.recurrence = document.getElementById('itemRecurrence').value;
  item.n = parseInt(document.getElementById('itemN').value)||1;

  if(currentItem.type==='income'){
    item.accountId = document.getElementById('itemAccount').value || (getDebitAccounts()[0]||{}).id || null;
  } else {
    item.payMethod = document.getElementById('expensePayMethod').value || 'debit';
    item.debitAccountId = document.getElementById('expenseDebitAccount').value || (getDebitAccounts()[0]||{}).id || null;
    item.creditAccountId = (item.payMethod === 'credit') ? (document.getElementById('expenseCreditAccount').value || null) : null;
    item.categoryId = document.getElementById('expenseCategory').value || 'uncat';
    if(!billCategories.some(c=>c.id===item.categoryId)) item.categoryId = 'uncat';
    if(item.payMethod === 'credit' && !item.creditAccountId) item.payMethod = 'debit';
  }

  // Persist new items only when user clicks Save
  if(isNew){
    if(currentItem.type==='income') incomes.push(item);
    else expenses.push(item);
  }

  saveData();
  renderDashboard();
  closeItemModal();
  computeForecast();
}
function deleteItemModal(){
  if(!currentItem) return;
  if(currentItem.isNew){
    closeItemModal();
    return;
  }
  if(currentItem.type==='income') incomes.splice(currentItem.index,1);
  else expenses.splice(currentItem.index,1);

  saveData();
  renderDashboard();
  computeForecast();
  closeItemModal();
}

// ---------- Recurrence ----------
function occursOn(item, date){
  const start = parseDate(item.date);
  if(date < start) return false;

  switch(item.recurrence){
    case 'once':
      return formatDate(start) === formatDate(date);

    case 'every_n_week': {
      const diffDays = Math.floor((date - start) / (1000*60*60*24));
      return diffDays >= 0 && diffDays % (7 * (item.n||1)) === 0;
    }

    case 'every_n_month': {
      const monthsDiff = (date.getFullYear()-start.getFullYear())*12 + (date.getMonth()-start.getMonth());
      return date.getDate() === start.getDate() && monthsDiff >= 0 && monthsDiff % (item.n||1) === 0;
    }

    default:
      return false;
  }
}

// ---------- Credit Card Due Date Logic ----------
function computeNextDueDate(chargeDate, dueDay){
  // Returns a Date object for the next due date after (or on) chargeDate, based on dueDay (1-28).
  const d = clamp(parseInt(dueDay||1,10),1,28);
  const y = chargeDate.getFullYear();
  const m = chargeDate.getMonth();

  const sameMonthDue = new Date(y, m, d);
  // If the due day in the same month is >= the charge date (by day), use it; else next month.
  // Compare by date-only
  const chargeDay = new Date(y, m, chargeDate.getDate());
  const dueDayDate = new Date(sameMonthDue.getFullYear(), sameMonthDue.getMonth(), sameMonthDue.getDate());

  if(dueDayDate >= chargeDay) return sameMonthDue;
  return new Date(y, m+1, d);
}

function computeCCPaymentDueDate(chargeDate, statementCloseDay, paymentDueDay){
  // Determine which statement the charge falls into (based on statementCloseDay),
  // then schedule the CASH payment on the credit card's PAYMENT due day (paymentDueDay)
  // in the month after the statement closes.
  //
  // All day-of-month fields are clamped to 1–28 to avoid month-length edge cases.
  const closeDay = clamp(parseInt(statementCloseDay||1,10),1,28);
  const dueDay   = clamp(parseInt(paymentDueDay||1,10),1,28);

  const y = chargeDate.getFullYear();
  const m = chargeDate.getMonth();

  // Statement close date for "this month"
  const closeThisMonth = new Date(y, m, closeDay);

  const chargeDay = new Date(y, m, chargeDate.getDate());
  const closeDayDate = new Date(closeThisMonth.getFullYear(), closeThisMonth.getMonth(), closeThisMonth.getDate());

  // If the charge occurs on/before close day, it belongs to this month's statement.
  // Otherwise it rolls into next month's statement.
  const statementClose = (chargeDay <= closeDayDate) ? closeThisMonth : new Date(y, m+1, closeDay);

  // Payment is due in the month after the statement closes, on the card's payment due day.
  return new Date(statementClose.getFullYear(), statementClose.getMonth()+1, dueDay);
}

// ---------- Forecast ----------
function computeForecast(){
  
  try{ syncLinkedCreditCardDebtBalances(); }catch(e){}
// Pull latest dashboard balances (accounts + debts) before computing forecast
  applyDashboardBalancesToData();
  // Auto-create CC payment bills for unlinked credit cards (statement + extra)
  try{ refreshAutoCCBills(); }catch(e){}
  currentBalance = parseFloat(document.getElementById('balance').value) || 0;


  // Ensure debt-plan generated expenses are up to date for the calendar/forecast
  try{
    removeGeneratedDebtExpenses();
  if(debtPlan && debtPlan.applyToForecast){ injectDebtPlanExpenses(null); }
  }catch(e){}
  dailyBalances = [];
  multiMonthData = [];

  const now = new Date();
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

  // Today’s forecasted balance should equal the current balance (no retro calculation)
  let balanceTracker = currentBalance;
  dailyBalances.push({date:new Date(today), income:0, bills:0, balance:balanceTracker, notes:[]});

  // Pre-compute CC payment buckets: dueDateStr -> {total, breakdown[]}
  // We'll apply these as "bills" on the due date.
  const ccBuckets = {};
  window.__ccBuckets = ccBuckets;
 // key: yyyy-mm-dd -> {total:number, notes:string[]}

  function bucketCCPayment(chargeName, amount, chargeDate, creditAccountId){
    const cc = accounts.find(a=>a.id===creditAccountId && a.type==='credit');
    if(!cc) return;

    const dueDate = computeCCPaymentDueDate(chargeDate, (cc.statementCloseDay!=null?cc.statementCloseDay:(cc.dueDay||1)), (cc.dueDay||1));
    const key = formatDate(dueDate);
    if(!ccBuckets[key]) ccBuckets[key] = {total:0, notes:[], byCard:{}};
    ccBuckets[key].total += amount;
    const note = `${cc.name}: ${chargeName} (${money(amount)})`;
    ccBuckets[key].notes.push(note);
    if(!ccBuckets[key].byCard[cc.id]) ccBuckets[key].byCard[cc.id] = {id:cc.id, name:cc.name, total:0, notes:[]};
    ccBuckets[key].byCard[cc.id].total += amount;
    ccBuckets[key].byCard[cc.id].notes.push(note);
  }

  // Build buckets for all future occurrences in the 5-year window
  // We'll generate day-by-day anyway; for simplicity we bucket inside the loop too.
  for(let m=0; m<60; m++){
    const monthStart = new Date(today.getFullYear(), today.getMonth()+m, 1);
    const daysInMonth = new Date(monthStart.getFullYear(), monthStart.getMonth()+1, 0).getDate();

    let monthIncome = 0, monthBills = 0;

    for(let d=1; d<=daysInMonth; d++){
      const date = new Date(monthStart.getFullYear(), monthStart.getMonth(), d);
      const dayDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());

      // Only forecast future days (strictly after today). Skip past days entirely.
      if(dayDate <= today) continue;

      let dayIncome = 0;
      let dayBills = 0;
      const notes = [];

      // Income hits on its date
      incomes.forEach(i=>{
        if(occursOn(i, date)){
          dayIncome += (parseFloat(i.amount)||0);
        }
      });

      // Expenses: if debit -> hit on bill date; if credit -> bucket to due date
      expenses.forEach(e=>{
    if(e && e.enabled === false) return;
        if(!occursOn(e, date)) return;
        if(isPaidOccurrence(date, e.id)) {
          // Marked paid for this specific day occurrence; do not apply to forecast.
          return;
        }

        const amt = (parseFloat(e.amount)||0);

        if((e.payMethod||'debit') === 'credit' && e.creditAccountId){
          bucketCCPayment(e.name, amt, date, e.creditAccountId);
          // Not counted as cash bills today.
        } else {
          dayBills += amt;
        }
      });

      // Apply any CC payments due today
      const key = formatDate(date);
      if(ccBuckets[key]){
        dayBills += ccBuckets[key].total;
        notes.push(...ccBuckets[key].notes.map(n=>`CC Payment Due • ${n}`));
      }

      balanceTracker += (dayIncome - dayBills);

      dailyBalances.push({date, income:dayIncome, bills:dayBills, balance:balanceTracker, notes});
      monthIncome += dayIncome;
      monthBills += dayBills;
    }

    multiMonthData.push({
      month: monthStart.toLocaleString('default',{month:'long',year:'numeric'}),
      income: monthIncome,
      bills: monthBills,
      balance: balanceTracker
    });
  }

  renderCalendar();
  renderMultiMonth();
  renderDashboard();
  renderBillsPage();
updateDebtWarnings();
  saveData();
}

// --- Legacy compatibility: some UI handlers call calculateForecast() ---
function calculateForecast(){
  return computeForecast();
}
// Ensure global reference exists for wrappers and inline handlers
window.calculateForecast = calculateForecast;
// Re-run publish wrapper now that calculateForecast exists
try{ if (typeof _mm_publishForecastGlobals === 'function') _mm_publishForecastGlobals(); }catch(e){}


// ---------- Calendar ----------

function renderCalendar() {
  const container = document.getElementById('calendarTab');
  container.innerHTML = '';

  // Ensure a stable month cursor (defaults to current month)
  const today = new Date();
  if (!window.__mm_calendarCursor) {
    window.__mm_calendarCursor = new Date(today.getFullYear(), today.getMonth(), 1);
  }
  const cursor = new Date(window.__mm_calendarCursor.getFullYear(), window.__mm_calendarCursor.getMonth(), 1);

  const monthLabel = cursor.toLocaleString('default', { month: 'long', year: 'numeric' });

  // ----- Header (Prev / Next) -----
  const header = document.createElement('div');
  header.className = 'flex items-center justify-between bg-white rounded-xl shadow p-3';

  const leftBtn = document.createElement('button');
  leftBtn.className = 'px-3 py-2 rounded-lg border text-sm';
  leftBtn.textContent = '←';
  leftBtn.onclick = () => {
    window.__mm_calendarCursor = new Date(cursor.getFullYear(), cursor.getMonth() - 1, 1);
    renderCalendar();
  };

  const title = document.createElement('div');
  title.className = 'font-bold text-lg';
  title.textContent = monthLabel;

  const rightBtn = document.createElement('button');
  rightBtn.className = 'px-3 py-2 rounded-lg border text-sm';
  rightBtn.textContent = '→';
  rightBtn.onclick = () => {
    window.__mm_calendarCursor = new Date(cursor.getFullYear(), cursor.getMonth() + 1, 1);
    renderCalendar();
  };

  header.appendChild(leftBtn);
  header.appendChild(title);
  header.appendChild(rightBtn);
  container.appendChild(header);

  // ----- Weekday header -----
  const weekdays = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
  const weekHeader = document.createElement('div');
  weekHeader.className = 'calendar-grid font-semibold mt-3';
  weekdays.forEach(w => {
    const div = document.createElement('div');
    div.textContent = w;
    div.className = 'text-center text-xs text-gray-600';
    weekHeader.appendChild(div);
  });
  container.appendChild(weekHeader);

  // ----- Calendar grid (one month) -----
  const grid = document.createElement('div');
  grid.className = 'calendar-grid';

  const firstDate = new Date(cursor.getFullYear(), cursor.getMonth(), 1);
  const daysInMonth = new Date(firstDate.getFullYear(), firstDate.getMonth() + 1, 0).getDate();
  const startDay = firstDate.getDay();

  for (let i = 0; i < startDay; i++) {
    const emptyDiv = document.createElement('div');
    grid.appendChild(emptyDiv);
  }

  for (let d = 1; d <= daysInMonth; d++) {
    const date = new Date(firstDate.getFullYear(), firstDate.getMonth(), d);
    const isPast = date.setHours(0,0,0,0) < new Date().setHours(0,0,0,0);
    const dayObj = dailyBalances.find(x => x.date.toDateString() === new Date(firstDate.getFullYear(), firstDate.getMonth(), d).toDateString());

    const cell = document.createElement('div');
    cell.className = 'calendar-day relative p-1 min-h-[70px] border rounded flex flex-col bg-white';
    if (isPast) cell.classList.add('opacity-60');
    if (!dayObj) cell.classList.add('cursor-not-allowed');
    else cell.classList.add('cursor-pointer');

    const dayNumber = document.createElement('div');
    dayNumber.className = 'font-bold text-sm';
    dayNumber.textContent = d;
    cell.appendChild(dayNumber);

    const listContainer = document.createElement('div');
    listContainer.className = 'flex-1 overflow-auto mt-1 text-[11px] space-y-0.5';

    // Income labels
    incomes.filter(i => occursOn(i, date)).slice(0,3).forEach(i => {
      const incDiv = document.createElement('div');
      incDiv.className = 'text-green-700 truncate';
      incDiv.textContent = i.name;
      listContainer.appendChild(incDiv);
    });

    // Bills labels (cash-impact in red; credit-paid informational in purple; CC due in red)
    const cashBills = expenses
      .filter(e => e && e.enabled !== false && occursOn(e, date) && (e.payMethod||'debit') !== 'credit');
    const infoBills = expenses
      .filter(e => e && e.enabled !== false && occursOn(e, date) && (e.payMethod||'debit') === 'credit');

    cashBills.slice(0,3).forEach(e => {
      const paid = isPaidOccurrence(date, e.id);
      const billDiv = document.createElement('div');
      billDiv.className = (paid ? 'text-gray-400 truncate line-through' : 'text-red-600 truncate');
      billDiv.textContent = e.name;
      listContainer.appendChild(billDiv);
    });

    infoBills.slice(0,2).forEach(e => {
      const infoDiv = document.createElement('div');
      infoDiv.className = 'text-purple-700 truncate';
      infoDiv.textContent = e.name;
      listContainer.appendChild(infoDiv);
    });

    const ccKey = formatDate(date);
    if (window.__ccBuckets && window.__ccBuckets[ccKey] && window.__ccBuckets[ccKey].total > 0) {
      const ccDiv = document.createElement('div');
      ccDiv.className = 'text-red-600 truncate';
      ccDiv.textContent = `CC Payment Due (${money(window.__ccBuckets[ccKey].total)})`;
      listContainer.appendChild(ccDiv);
    }
cell.appendChild(listContainer);

    if (dayObj) {
      cell.onclick = () => showDayDetails(new Date(firstDate.getFullYear(), firstDate.getMonth(), d));
    }

    grid.appendChild(cell);
  }

  container.appendChild(grid);

  // ----- Daily Table under calendar -----
  const tableWrap = document.createElement('div');
  tableWrap.className = 'mt-4 bg-white rounded-xl shadow overflow-auto border';

  const table = document.createElement('table');
  table.className = 'w-full text-sm';
  table.innerHTML = `
    <thead class="bg-gray-100 sticky top-0">
      <tr>
        <th class="p-2 text-left">Date</th>
        <th class="p-2 text-right">Income</th>
        <th class="p-2 text-right">Expenses</th>
        <th class="p-2 text-right">Forecast</th>
      </tr>
    </thead>
    <tbody></tbody>
  `;

  const tbody = table.querySelector('tbody');

  function dayIncomeTotal(date) {
    return incomes.filter(i => occursOn(i, date)).reduce((s,i)=>s+Number(i.amount||0),0);
  }
  function dayExpensesTotal(date) {
    return expenses
      .filter(e => e && e.enabled !== false && occursOn(e, date) && (e.payMethod||'debit') !== 'credit')
      .reduce((s,e)=>{
        const paid = isPaidOccurrence(date, e.id);
        return s + (paid ? 0 : Number(e.amount||0));
      },0);
  }

  for (let d = 1; d <= daysInMonth; d++) {
    const date = new Date(firstDate.getFullYear(), firstDate.getMonth(), d);
    const dayObj = dailyBalances.find(x => x.date.toDateString() === date.toDateString());

    // Prefer forecast-derived numbers (these include credit-card payments due on this day)
    const inc = (dayObj && typeof dayObj.income === 'number') ? dayObj.income : dayIncomeTotal(date);
    const expensesShown = (dayObj && typeof dayObj.bills === 'number') ? dayObj.bills : dayExpensesTotal(date);

    const forecast = dayObj ? dayObj.balance : null;

    const tr = document.createElement('tr');
    const clickable = !!dayObj;
    const isPastRow = date.setHours(0,0,0,0) < new Date().setHours(0,0,0,0);
    tr.className = 'border-t ' 
      + (isPastRow ? 'bg-gray-50 opacity-60 ' : '')
      + (clickable ? 'cursor-pointer hover:bg-gray-50' : 'text-gray-400');
    tr.innerHTML = `
      <td class="p-2">${date.toLocaleDateString(undefined, { weekday:'short', month:'short', day:'numeric' })}</td>
      <td class="p-2 text-right text-green-700">${money(inc)}</td>
      <td class="p-2 text-right ${expensesShown>0 ? 'text-red-600' : 'text-gray-500'}">${money(expensesShown)}</td>
      <td class="p-2 text-right">${forecast===null ? '—' : money(forecast)}</td>
    `;
    if (clickable) tr.onclick = () => showDayDetails(date);
    tbody.appendChild(tr);
}

  tableWrap.appendChild(table);
  container.appendChild(tableWrap);
}

// ---------- Day Modal ----------
function showDayDetails(date) {
  const day = dailyBalances.find(d => d.date.toDateString() === date.toDateString());
  if (!day) return;

  // Track current day being shown (used for swipe navigation)
  currentDayModalDate = new Date(date.getTime());

  const modal = document.getElementById('dayModal');
  if (modal) modal.classList.remove('hidden');

  document.getElementById('modalDate').textContent = date.toDateString();
  document.getElementById('modalBalance').textContent = `${money(day.balance)}`;

  const incomeEl = document.getElementById('modalIncome');
  const billsEl  = document.getElementById('modalBills');
  if (!incomeEl || !billsEl) return;

  // Fade lists for a smoother “refresh” feel
  incomeEl.classList.add('opacity-0');
  billsEl.classList.add('opacity-0');

  const renderId = ++dayModalRenderToken;

  setTimeout(() => {
    if (renderId !== dayModalRenderToken) return;

    incomeEl.innerHTML = '';
    billsEl.innerHTML  = '';

    // Income rows + total
    const todaysIncomes = incomes.filter(i => occursOn(i, date));
    const totalIncome = todaysIncomes.reduce((s,i)=>s+Number(i.amount||0),0);

    todaysIncomes.forEach(i => {
      const li = document.createElement('li');
      li.className = 'px-3 py-2 flex items-center justify-between gap-3 mm-fade-in';

      const name = document.createElement('div');
      name.className = 'text-green-700 truncate';
      name.textContent = i.name;

      const amt = document.createElement('div');
      amt.className = 'font-semibold text-green-800 whitespace-nowrap text-right';
      amt.textContent = money(i.amount);

      li.appendChild(name);
      li.appendChild(amt);
      incomeEl.appendChild(li);
    });

    if (!todaysIncomes.length) {
      const li = document.createElement('li');
      li.className = 'px-3 py-3 text-gray-400 italic mm-fade-in';
      li.textContent = 'No income';
      incomeEl.appendChild(li);
    }

    // Income subtotal (always at bottom)
    {
      const li = document.createElement('li');
      li.className = 'px-3 py-2 flex items-center justify-between bg-gray-50 font-semibold mm-fade-in';
      const label = document.createElement('div');
      label.className = 'text-gray-700';
      label.textContent = 'Subtotal';
      const amt = document.createElement('div');
      amt.className = 'text-gray-900 whitespace-nowrap text-right';
      amt.textContent = money(totalIncome);
      li.appendChild(label);
      li.appendChild(amt);
      incomeEl.appendChild(li);
    }

    // Bills rows + unpaid total (paid occurrences are excluded from forecast)
// Show CASH-impact bills in red, show credit-card-paid items separately as informational (purple),
// and show a single expandable "Credit card payment due" row (red) on due dates.
const infoEl = document.getElementById('dayModalInfo');
const infoTotalEl = document.getElementById('dayModalInfoTotal');
if (infoEl) infoEl.innerHTML = '';
if (infoTotalEl) infoTotalEl.textContent = money(0);

const isCreditPay = (e)=>{ 
  const pm = String((e && e.payMethod) || 'debit').toLowerCase();
  return pm === 'credit' || pm === 'cc' || pm === 'card' || pm.includes('credit');
};
const todaysCashBills = expenses.filter(e => e && e.enabled !== false && !isCreditPay(e) && occursOn(e, date));
const todaysInfoBills = expenses.filter(e => e && e.enabled !== false && isCreditPay(e) && occursOn(e, date));

let totalBillsUnpaid = 0;
// --- Credit card payment due (one line per card) ---
const ccKey = formatDate(date);
const ccBucket = (window.__ccBuckets && window.__ccBuckets[ccKey]) ? window.__ccBuckets[ccKey] : null;
const ccCards = (ccBucket && ccBucket.byCard) ? Object.values(ccBucket.byCard) : [];
if (ccCards.length) {
  ccCards
    .filter(c => Number(c.total || 0) > 0)
    .sort((a,b)=>String(a.name||'').localeCompare(String(b.name||'')))
    .forEach(c => {
      totalBillsUnpaid += Number(c.total || 0);

      const li = document.createElement('li');
      li.className = 'px-3 py-2 flex items-center justify-between gap-3 mm-fade-in';

      const left = document.createElement('div');
      left.className = 'min-w-0 flex-1';

      const title = document.createElement('div');
      title.className = 'text-red-700 font-semibold truncate';
      title.textContent = `${c.name} payment due`;

      const meta = document.createElement('div');
      meta.className = 'text-xs text-gray-400 truncate';
      meta.textContent = 'Credit card payment due';

      left.appendChild(title);
      left.appendChild(meta);

      const amt = document.createElement('div');
      amt.className = 'text-red-700 font-semibold whitespace-nowrap flex-none text-right';
      amt.textContent = money(c.total);

      li.appendChild(left);
      li.appendChild(amt);
      billsEl.appendChild(li);
    });
}

// --- Cash bills (red) ---
todaysCashBills.forEach(e => {
  const isPaid = isPaidOccurrence(date, e.id);
  if (!isPaid) totalBillsUnpaid += Number(e.amount || 0);

  const li = document.createElement('li');
  li.className = 'px-3 py-2 flex items-center justify-between gap-3 mm-fade-in' + (isPaid ? ' opacity-60' : '');

  const left = document.createElement('div');
  left.className = 'min-w-0 flex-1';

  const topRow = document.createElement('div');
  topRow.className = 'flex items-center gap-2';

  if (isPaid) {
    const check = document.createElement('span');
    check.className = 'inline-flex items-center justify-center w-5 h-5 rounded-full bg-green-100 text-green-700 text-xs flex-none';
    check.textContent = '✓';
    topRow.appendChild(check);
  }

  const name = document.createElement('div');
  name.className = (isPaid ? 'text-gray-500 line-through truncate' : 'text-red-700 truncate');
  name.textContent = e.name;

  topRow.appendChild(name);

  const meta = document.createElement('div');
  meta.className = 'text-xs text-gray-400 truncate';
  meta.textContent = 'Cash / debit';

  left.appendChild(topRow);
  left.appendChild(meta);

  const right = document.createElement('div');
  right.className = 'flex items-center gap-3 flex-none';

  const amt = document.createElement('div');
  amt.className = (isPaid ? 'text-gray-500 line-through font-semibold whitespace-nowrap text-right' : 'text-red-800 font-semibold whitespace-nowrap text-right');
  amt.textContent = money(e.amount);

  const paidWrap = document.createElement('label');
  paidWrap.className = 'inline-flex items-center gap-2 text-xs text-gray-600 select-none';

  const cb = document.createElement('input');
  cb.type = 'checkbox';
  cb.checked = isPaid;
  cb.className = 'accent-green-600';
  cb.onchange = () => {
    if (cb.checked) setPaidOccurrence(date, e.id, true);
    else setPaidOccurrence(date, e.id, false);
    calculateForecast();
    renderCalendar();
    showDayDetails(date);
  };

  const span = document.createElement('span');
  span.textContent = 'Paid';

  paidWrap.appendChild(cb);
  paidWrap.appendChild(span);

  right.appendChild(amt);
  right.appendChild(paidWrap);

  li.appendChild(left);
  li.appendChild(right);
  billsEl.appendChild(li);
});

// If no cash-impact bills and no CC due line, show placeholder
const hasCcDueLine = !!(ccCards && ccCards.some(c => Number(c.total||0) > 0.0001));
if (!todaysCashBills.length && !hasCcDueLine) {
  const li = document.createElement('li');
  li.className = 'px-3 py-3 text-gray-400 italic mm-fade-in';
  li.textContent = 'No expenses';
  billsEl.appendChild(li);
}

// Expenses subtotal (unpaid)
{
  const li = document.createElement('li');
  li.className = 'px-3 py-2 flex items-center justify-between bg-gray-50 font-semibold mm-fade-in';
  const label = document.createElement('div');
  label.className = 'text-gray-700';
  label.textContent = 'Subtotal';
  const amt = document.createElement('div');
  amt.className = 'text-gray-900 whitespace-nowrap text-right';
  amt.textContent = money(totalBillsUnpaid);
  li.appendChild(label);
  li.appendChild(amt);
  billsEl.appendChild(li);
}

// --- Informational section (purple): credit-card-paid items + any notes ---
let infoTotal = 0;

if(infoEl){
  if(todaysInfoBills.length){
    todaysInfoBills.forEach(e=>{
      infoTotal += Number(e.amount||0);

      const li = document.createElement('li');
      li.className = 'px-3 py-2 flex items-center justify-between gap-3 mm-fade-in';

      const name = document.createElement('div');
      name.className = 'text-purple-700 truncate';
      name.textContent = e.name;

      const amt = document.createElement('div');
      amt.className = 'text-purple-700 font-semibold whitespace-nowrap';
      amt.textContent = money(e.amount);

      li.appendChild(name);
      li.appendChild(amt);
      infoEl.appendChild(li);
    });
  }

  // Add any notes (kept informational)
  const rawNotes = Array.isArray(day.notes) ? day.notes : [];
  const infoNotes = rawNotes.filter(n => !String(n || '').startsWith('CC Payment Due'));
  infoNotes.forEach(n=>{
    const li = document.createElement('li');
    li.className = 'px-3 py-2 text-purple-700 mm-fade-in';
    li.textContent = n;
    infoEl.appendChild(li);
  });

  if(!todaysInfoBills.length && !infoNotes.length){
    const li = document.createElement('li');
    li.className = 'px-3 py-3 text-gray-400 italic mm-fade-in';
    li.textContent = 'No informational items';
    infoEl.appendChild(li);
  }
}

if(infoTotalEl){
  infoTotalEl.textContent = money(infoTotal);
}

// Totals in header cards
    const ti = document.getElementById('dayModalTotalIncome');
    const tb = document.getElementById('dayModalTotalBills');
    if (ti) ti.textContent = money(totalIncome);
    if (tb) tb.textContent = money(totalBillsUnpaid);

    requestAnimationFrame(() => {
      incomeEl.classList.remove('opacity-0');
      billsEl.classList.remove('opacity-0');
    });
  }, 90);
}

function setupDayModalSwipe(){
  const modal = document.getElementById('dayModal');
  if (!modal) return;
  const panel = modal.querySelector('.modal-panel');
  if (!panel) return;

  let x0=null, y0=null, t0=0;

  panel.addEventListener('touchstart', (e)=>{
    if (modal.classList.contains('hidden')) return;
    if (!e.touches || e.touches.length !== 1) return;
    x0 = e.touches[0].clientX;
    y0 = e.touches[0].clientY;
    t0 = Date.now();
  }, {passive:true});

  panel.addEventListener('touchend', (e)=>{
    if (modal.classList.contains('hidden')) return;
    if (x0 === null || !e.changedTouches || e.changedTouches.length < 1) return;

    const dx = e.changedTouches[0].clientX - x0;
    const dy = e.changedTouches[0].clientY - y0;
    const dt = Date.now() - t0;

    x0 = null; y0 = null;

    // Quick, mostly-horizontal swipes only
    if (dt > 650) return;
    if (Math.abs(dx) < 60) return;
    if (Math.abs(dy) > 40) return;

    if (!currentDayModalDate) return;

    const next = new Date(currentDayModalDate.getTime());
    next.setDate(next.getDate() + (dx < 0 ? 1 : -1)); // swipe left => next day, swipe right => previous day
    showDayDetails(next);
  }, {passive:true});
}

function closeDayModal(){ document.getElementById('dayModal').classList.add('hidden'); }

// ---------- Multi-Month Table ----------
function renderMultiMonth(){
  const tbody=document.getElementById('multiMonthBody'); tbody.innerHTML='';
  multiMonthData.forEach((m,index)=>{
    const tr=document.createElement('tr');
    tr.className='border-b cursor-pointer';
    tr.onclick=()=>showMonthDetails(index);
    tr.innerHTML=`<td class="p-2">${m.month}</td><td class="p-2">${money(m.income)}</td><td class="p-2">${money(m.bills)}</td><td class="p-2">${money(m.balance)}</td>`;
    tbody.appendChild(tr);
  });
}


function renderMonthlyForecastChart(){
  // Dashboard forecast chart with view modes: day (scrolling), month, year.
  const canvas = document.getElementById('dailyForecastCanvas');
  const scroll = document.getElementById('dailyForecastScroll');
  const hint = document.getElementById('forecastScrollHint');
  if(!canvas || !scroll) return;

  // Ensure view exists
  window._mm_forecastView = window._mm_forecastView || 'month';

  // Normalize dailyBalances -> rows[{date,balance}] sorted
  let rows = Array.isArray(dailyBalances) ? dailyBalances.slice() : [];
  rows = rows
    .map(r=>({
      date: (r && r.date instanceof Date) ? r.date : new Date(r?.date),
      balance: Number(r?.balance ?? r?.bal ?? r?.amount ?? 0)
    }))
    .filter(r=> r.date instanceof Date && !isNaN(r.date.getTime()) && isFinite(r.balance))
    .sort((a,b)=>a.date-b.date);

  // Destroy previous chart if any
  try{ window._mm_dailyForecastChart?.destroy?.(); }catch(e){}
  window._mm_dailyForecastChart = null;

  // If we don't have data, reset canvas to baseline width
  if(rows.length < 10){
    canvas.width = 400;
    canvas.height = 180;
    canvas.style.width = '400px';
    canvas.style.height = '180px';
    const ctx0 = canvas.getContext('2d');
    try{ ctx0.clearRect(0,0,canvas.width,canvas.height); }catch(e){}
    if(hint) hint.classList.add('hidden');
    return;
  }

  // Horizon by view
  const view = (window._mm_forecastView === 'year') ? 'year' : (window._mm_forecastView === 'month' ? 'month' : 'day');
  const horizonMonths = (view === 'year') ? 60 : 12;

  // Limit horizon (keeps charts fast + matches requested views)
  const startDate = new Date(rows[0].date.getFullYear(), rows[0].date.getMonth(), rows[0].date.getDate());
  const endLimit = new Date(startDate.getFullYear(), startDate.getMonth()+horizonMonths, startDate.getDate());
  rows = rows.filter(r=> r.date <= endLimit);


  // --------- helpers ---------
  const fmtMoney0 = (n)=> '$' + (Number(n)||0).toLocaleString(undefined,{maximumFractionDigits:0});
  const fmtMoney2 = (n)=> '$' + (Number(n)||0).toLocaleString(undefined,{minimumFractionDigits:2, maximumFractionDigits:2});

  function aggregateRows(mode){
    if(mode === 'month'){
      const by = new Map(); // 'YYYY-MM' -> {date,balance} (last point in month)
      for(const r of rows){
        const d = r.date;
        const key = d.getFullYear() + '-' + String(d.getMonth()+1).padStart(2,'0');
        const prev = by.get(key);
        if(!prev || d > prev.date) by.set(key, {date: new Date(d.getFullYear(), d.getMonth(), 1), balance: r.balance});
      }
      const out = Array.from(by.entries())
        .sort((a,b)=>a[0].localeCompare(b[0]))
        .map(([k,v])=>({key:k, date:v.date, balance:v.balance, label: v.date.toLocaleString(undefined,{month:'short', year:'numeric'})}));
      return out.slice(0, 12);
    }
    if(mode === 'year'){
      const by = new Map(); // 'YYYY' -> last point in year
      for(const r of rows){
        const d = r.date;
        const key = String(d.getFullYear());
        const prev = by.get(key);
        if(!prev || d > prev.date) by.set(key, {date: new Date(d.getFullYear(), 0, 1), balance: r.balance});
      }
      const out = Array.from(by.entries())
        .sort((a,b)=>a[0].localeCompare(b[0]))
        .map(([k,v])=>({key:k, date:v.date, balance:v.balance, label: k}));
      return out.slice(0, 5);
    }
    // day
    return rows.map(r=>{
      const d=r.date;
      const y=d.getFullYear(), m=String(d.getMonth()+1).padStart(2,'0'), da=String(d.getDate()).padStart(2,'0');
      return { key:`${y}-${m}-${da}`, date:d, balance:r.balance, label:`${y}-${m}-${da}` };
    });
  }
  // view already set above
  const pts = aggregateRows(view);
  const labels = pts.map(p=>p.label);
  const data = pts.map(p=>p.balance);

  // Layout rules:
  // - Day: wide scrolling canvas
  // - Month/Year: responsive fixed-width canvas
  const pxPerPoint = (view==='day') ? 12 : (view==='month' ? 40 : 80);
  const width = (view==='day')
    ? Math.max(400, pts.length * pxPerPoint)
    : Math.max(400, Math.min(900, pts.length * pxPerPoint));

  canvas.width = width;
  canvas.height = 180;
  canvas.style.width = (view==='day' ? (width + 'px') : '100%');
  canvas.style.height = '180px';

  // Toggle scroll affordance
  if(hint){
    if(view==='day') hint.classList.remove('hidden');
    else hint.classList.add('hidden');
  }
  if(view==='day'){
    scroll.classList.add('overflow-x-auto');
  }else{
    // keep container scrollable (harmless), but reset position
    try{ scroll.scrollLeft = 0; }catch(e){}
  }

  const ctx = canvas.getContext('2d');

  // Subtle gradient fill for a more polished look
  let fill = false;
  try{
    const g = ctx.createLinearGradient(0, 0, 0, canvas.height);
    g.addColorStop(0, 'rgba(34,197,94,0.20)');
    g.addColorStop(1, 'rgba(34,197,94,0.00)');
    fill = g;
  }catch(e){ fill = false; }

  window._mm_dailyForecastChart = new Chart(ctx, {
    type: 'line',
    data: {
      labels,
      datasets: [{
        label: 'Forecasted Balance',
        data,
        tension: 0.25,
        fill: !!fill,
        backgroundColor: fill || undefined,
        borderColor: 'rgb(34,197,94)',
        borderWidth: 2,
        pointRadius: (view==='day') ? 0 : 2,
        pointHoverRadius: 4,
        pointHitRadius: 12
      }]
    },
    options: {
      responsive: (view !== 'day'),
      maintainAspectRatio: false,
      interaction: { mode: 'index', intersect: false },
      plugins: {
        legend: { display: false },
        tooltip: {
          callbacks: {
            title: (items)=>{
              const i = items?.[0]?.dataIndex ?? 0;
              const dt = pts[i]?.date;
              if(!dt) return '';
              if(view==='day') return dt.toLocaleDateString();
              if(view==='month') return dt.toLocaleString(undefined,{month:'long', year:'numeric'});
              return String(dt.getFullYear());
            },
            label: (item)=> ` ${fmtMoney2(item.parsed?.y)}`
          }
        }
      },
      scales: {
        x: {
          grid: { display: false },
          ticks: {
            autoSkip: true,
            maxTicksLimit: (view==='day') ? 14 : 12,
            maxRotation: 0,
            minRotation: 0,
            font: { size: 10 },
            callback: function(value){
              const label = this.getLabelForValue(value);
              if(view==='day'){
                // Show weekly ticks (every 7 days) plus the first
                const idx = Number(value)||0;
                if(idx===0 || idx%7===0){
                  const m = /^(\d{4})-(\d{2})-(\d{2})$/.exec(String(label));
                  if(m){
                    const d = new Date(Number(m[1]), Number(m[2])-1, Number(m[3]));
                    return new Intl.DateTimeFormat(undefined, { month:'numeric', day:'numeric' }).format(d);
                  }
                  return label;
                }
                return '';
              }
              return label;
            }
          }
        },
        y: {
          grid: { drawBorder: false },
          ticks: { callback: (v)=> fmtMoney0(v) }
        }
      }
    }
  });

  // Start at left for day view
  if(view==='day'){
    try{ scroll.scrollLeft = 0; }catch(e){}
  }
}

// Dashboard chart view toggle
function setForecastView(mode){
  const m = (mode==='month' || mode==='year') ? mode : 'day';
  window._mm_forecastView = m;

  // Update button styles
  const dayBtn = document.getElementById('forecastViewDay');
  const monBtn = document.getElementById('forecastViewMonth');
  const yrBtn = document.getElementById('forecastViewYear');
  const all = [dayBtn, monBtn, yrBtn].filter(Boolean);
  all.forEach(b=>{
    b.classList.remove('bg-gray-900','text-white','font-semibold');
  });
  const active = (m==='day') ? dayBtn : (m==='month' ? monBtn : yrBtn);
  if(active){
    active.classList.add('bg-gray-900','text-white','font-semibold');
  }

  try{ renderMonthlyForecastChart(); }catch(e){}
}


function updateBillsMonthOptions(){
  const sel = document.getElementById('billsMonthSelect');
  if(!sel) return;

  // Preserve current selection (index or 'all')
  const prev = (sel.value !== '' ? sel.value : (billsSelectedMonthIndex === -1 ? 'all' : String(billsSelectedMonthIndex)));

  sel.innerHTML = '';

  // "All" option for category breakdown across all bills (estimated over next 5 years)
  const allOpt = document.createElement('option');
  allOpt.value = 'all';
  allOpt.textContent = 'All';
  sel.appendChild(allOpt);

  (multiMonthData||[]).forEach((m, idx)=>{
    const opt = document.createElement('option');
    opt.value = String(idx);
    opt.textContent = m.month;
    sel.appendChild(opt);
  });

  // Restore selection if possible
  if(prev === 'all'){
    billsSelectedMonthIndex = -1;
    sel.value = 'all';
  }else{
    billsSelectedMonthIndex = clamp(billsSelectedMonthIndex||0, 0, Math.max(0,(multiMonthData||[]).length-1));
    sel.value = String(billsSelectedMonthIndex);
  }

  sel.onchange = () => {
    if(sel.value === 'all'){
      billsSelectedMonthIndex = -1;
    }else{
      billsSelectedMonthIndex = parseInt(sel.value,10) || 0;
    }
    renderBillsPage();
};
}

function monthRangeFromLabel(label){
  // label like "Jan 2026"
  // We'll parse by creating Date from "1 " + label
  const d = new Date('1 ' + label);
  if(isNaN(d.getTime())){
    // fallback: current month
    const now = new Date();
    return {
      start: new Date(now.getFullYear(), now.getMonth(), 1),
      end: new Date(now.getFullYear(), now.getMonth()+1, 1)
    };
  }
  return {
    start: new Date(d.getFullYear(), d.getMonth(), 1),
    end: new Date(d.getFullYear(), d.getMonth()+1, 1)
  };
}

function renderBillsPage(){
  // Ensure auto CC bills are present in the Bills view
  try{ refreshAutoCCBills(); }catch(e){}
  const list = document.getElementById('billsList');
  const canvas = document.getElementById('billsPieChart');
  if(!list || !canvas) return;

  updateBillsMonthOptions();

  // If "All" is selected, compute category totals across all bills
  // (estimated by simulating occurrences over the next 5 years).
  let range = null;
  if(billsSelectedMonthIndex !== -1){
    const chosen = (multiMonthData||[])[billsSelectedMonthIndex];
    const label = chosen ? chosen.month : null;
    range = label ? monthRangeFromLabel(label) : monthRangeFromLabel(null);
  }
  // Totals by category (based on occurrences)
  const totalsByCat = {};

  function addToTotalsByDayRange(start, end){
    for(let d = new Date(start); d < end; d.setDate(d.getDate()+1)){
      expenses.forEach(e=>{
      if(e && e.enabled === false) return;
    if(e && e.enabled === false) return;
        if(occursOn(e, d)){
          const catId = e.categoryId || 'uncat';
          totalsByCat[catId] = (totalsByCat[catId]||0) + (Number(e.amount)||0);
        }
      });
    }
  }

  if(billsSelectedMonthIndex === -1){
    // "All" = simulate next 5 years starting from the current month
    const now = new Date();
    const base = new Date(now.getFullYear(), now.getMonth(), 1);
    for(let i=0; i<60; i++){
      const s = new Date(base.getFullYear(), base.getMonth()+i, 1);
      const e = new Date(base.getFullYear(), base.getMonth()+i+1, 1);
      addToTotalsByDayRange(s, e);
    }
  }else{
    addToTotalsByDayRange(range.start, range.end);
  }
  const pieLabels = Object.keys(totalsByCat).map(id=>getCategoryNameById(id));
  const pieData = Object.keys(totalsByCat).map(id=>Number(totalsByCat[id]||0));

    const sliceColors = Object.keys(totalsByCat).map(id=>{
    const c = billCategories.find(x=>x.id===id);
    return (c && c.color) ? c.color : '#9CA3AF';
  });

  if(billsPieChart){
    billsPieChart.data.labels = pieLabels;
    billsPieChart.data.datasets[0].data = pieData;
    
    billsPieChart.data.datasets[0].backgroundColor = sliceColors;
    billsPieChart.data.datasets[0].borderColor = '#ffffff';
    billsPieChart.data.datasets[0].borderWidth = 2;
billsPieChart.update();
  }else{
    billsPieChart = new Chart(canvas.getContext('2d'), {
      type: 'pie',
      plugins: [pieSliceLabelPlugin],
      data: {
        labels: pieLabels,
        datasets: [{
          data: pieData,
          backgroundColor: sliceColors,
          borderColor: '#ffffff',
          borderWidth: 2
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: { legend: { display: false } }
      }
    });
  }
  // Bills list is independent of the month selector (month affects ONLY the pie chart)
  list.innerHTML = '';

  // Show debt plan payments as ONE recurring line per debt (instead of 12 one-time generated rows)
  if(debtPlan && debtPlan.applyToForecast && Array.isArray(debts) && debts.length){
    ensureCategories();
    const debtCatId = ensureBillCategory('debt', 'Debt Payments');
    const debtCatObj = billCategories.find(c=>c.id===debtCatId) || {name:'Debt Payments', color:'#2563EB'};

    const header=document.createElement('div');
    header.className='mt-1 mb-1 flex items-center gap-2 text-sm font-semibold text-gray-700';
    const dot=document.createElement('span');
    dot.className='inline-block h-2.5 w-2.5 rounded-full';
    dot.style.background = debtCatObj.color || '#2563EB';
    const t=document.createElement('span');
    t.textContent = debtCatObj.name || 'Debt Payments';
    header.appendChild(dot);
    header.appendChild(t);
    list.appendChild(header);

    debts.slice().sort((a,b)=>(a.name||'').localeCompare(b.name||'')).forEach(d=>{
      const row=document.createElement('div');
      row.className='p-2 border rounded bg-white flex items-center justify-between gap-3 cursor-pointer';

      const left=document.createElement('div');
      left.className='min-w-0 flex-1';
      const title=document.createElement('div');
      title.className='font-medium truncate';
      title.textContent = `Debt Plan Payment • ${d.name || 'Debt'}`;
      const meta=document.createElement('div');
      meta.className='text-xs text-gray-500 truncate';
      meta.textContent = 'Paid with Debit • Every 1 month';
      left.appendChild(title);
      left.appendChild(meta);

      row.appendChild(left);

      row.onclick=()=>{
        if(typeof openDebtPlanPreviewModal==='function') openDebtPlanPreviewModal(d.id);
        else if(typeof openDebtPlanPreview==='function') openDebtPlanPreview(d.id);
      };
      list.appendChild(row);
    });
  }

  // Sort/group bills by category then alphabetically; include enable/disable toggle
  ensureCategories();

  const bills = (expenses||[]).map((e, idx)=>({e, idx})).filter(x=>x.e && !x.e._generatedByDebtPlan);
  bills.forEach(x=>{ if(!('enabled' in x.e)) x.e.enabled = true; });

  bills.sort((a,b)=>{
    const caObj = billCategories.find(c=>c.id=== (a.e.categoryId||'uncat')) || billCategories[0];
    const cbObj = billCategories.find(c=>c.id=== (b.e.categoryId||'uncat')) || billCategories[0];
    const ca = (caObj.name||'').toLowerCase();
    const cb = (cbObj.name||'').toLowerCase();
    if(ca < cb) return -1;
    if(ca > cb) return 1;
    const na = (a.e.name||'').toLowerCase();
    const nb = (b.e.name||'').toLowerCase();
    if(na < nb) return -1;
    if(na > nb) return 1;
    return 0;
  });

  let lastCatId = null;

  bills.forEach(({e, idx})=>{
    const catId = e.categoryId || 'uncat';
    const catObj = billCategories.find(c=>c.id===catId) || billCategories[0];

    if(catId !== lastCatId){
      lastCatId = catId;
      const header=document.createElement('div');
      header.className='mt-3 mb-1 flex items-center gap-2 text-sm font-semibold text-gray-700';
      const dot=document.createElement('span');
      dot.className='inline-block h-2.5 w-2.5 rounded-full';
      dot.style.background = catObj.color || '#9CA3AF';
      const t=document.createElement('span');
      t.textContent = catObj.name;
      header.appendChild(dot);
      header.appendChild(t);
      list.appendChild(header);
    }

    const row=document.createElement('div');
    row.className='p-2 border rounded bg-white flex items-center justify-between gap-3 cursor-pointer';
    if(e.enabled === false) row.style.opacity='0.55';

    const left=document.createElement('div');
    left.className='min-w-0 flex-1';
    const title=document.createElement('div');
    title.className='font-medium truncate';
    title.textContent = `${e.name} (${money(e.amount)})`;
    const meta=document.createElement('div');
    meta.className='text-xs text-gray-500 truncate';
    meta.textContent = `${(e.payMethod==='credit') ? 'Paid with Credit' : 'Paid with Debit'} • ${formatRecurrence(e.recurrence || 'once', e.n)}`;
    left.appendChild(title);
    left.appendChild(meta);

    const toggleWrap=document.createElement('label');
    toggleWrap.style.width='44px';
    toggleWrap.style.height='24px';
    toggleWrap.style.position='relative';
    toggleWrap.style.display='inline-block';
    toggleWrap.style.flex='0 0 auto';

    const cb=document.createElement('input');
    cb.type='checkbox';
    cb.checked = (e.enabled !== false);
    cb.style.opacity='0'; cb.style.width='0'; cb.style.height='0';

    const slider=document.createElement('span');
    slider.style.position='absolute';
    slider.style.inset='0';
    slider.style.borderRadius='999px';
    slider.style.background = cb.checked ? '#22C55E' : '#CBD5E1';
    slider.style.transition='0.15s';

    const knob=document.createElement('span');
    knob.style.position='absolute';
    knob.style.top='50%';
    knob.style.transform = cb.checked ? 'translate(20px,-50%)' : 'translate(4px,-50%)';
    knob.style.width='18px';
    knob.style.height='18px';
    knob.style.borderRadius='999px';
    knob.style.background='#fff';
    knob.style.transition='0.15s';

    slider.appendChild(knob);
    toggleWrap.appendChild(cb);
    toggleWrap.appendChild(slider);

    const updateToggleUI = ()=>{
      slider.style.background = cb.checked ? '#22C55E' : '#CBD5E1';
      knob.style.transform = cb.checked ? 'translate(20px,-50%)' : 'translate(4px,-50%)';
      row.style.opacity = cb.checked ? '1' : '0.55';
    };

    toggleWrap.addEventListener('click', (ev)=>ev.stopPropagation());
    cb.addEventListener('click', (ev)=>ev.stopPropagation());
    cb.addEventListener('change', ()=>{
      e.enabled = cb.checked;
      saveData();
      computeForecast();
      renderMonthlyForecastChart();
      // Update dashboard cards if on dashboard
      renderDashboard();
      updateToggleUI();
    });

    row.appendChild(left);
    row.appendChild(toggleWrap);
    row.onclick=()=>openItemModal('expense', idx);
    list.appendChild(row);
  });
}

// ---------- Month Details ----------
function showMonthDetails(index){
  const month = multiMonthData[index];
  if(!month) return;

  const days = dailyBalances
    .filter(d => d.date.toLocaleString('default', { month: 'long', year: 'numeric' }) === month.month)
    .sort((a,b)=>a.date-b.date);

  document.getElementById('monthModalTitle').textContent = month.month;

  const incomeEl = document.getElementById('monthModalIncome');
  const billsEl = document.getElementById('monthModalBills');
  const balanceEl = document.getElementById('monthModalBalance');
  const totalIncomeEl = document.getElementById('monthModalTotalIncome');
  const totalBillsEl = document.getElementById('monthModalTotalBills');

  incomeEl.innerHTML = '';
  billsEl.innerHTML = '';

  const infoEl = document.getElementById('monthModalInfo');
  const infoTotalEl = document.getElementById('monthModalInfoTotal');
  if (infoEl) infoEl.innerHTML = '';
  if (infoTotalEl) infoTotalEl.textContent = money(0);
  let infoTotal = 0;
  // Summary numbers (keep them compact for readability)
  balanceEl.textContent = money(month.balance);
  totalIncomeEl.textContent = money(month.income||0);
  totalBillsEl.textContent = money(month.bills||0);

  // Helper to add a “row” to a list (day badge + name + amount)
  function addRow(listEl, dayNum, title, amountText, color){
    const li = document.createElement('li');
    li.className = 'px-3 py-2';
    li.innerHTML = `
      <div class="flex items-center justify-between gap-3">
        <div class="min-w-0 flex items-center gap-2">
          <span class="inline-flex items-center justify-center w-8 h-6 rounded-md bg-gray-100 text-gray-700 text-xs font-semibold">${dayNum}</span>
          <span class="min-w-0 truncate ${color} font-medium">${title}</span>
        </div>
        ${amountText ? `<span class="${color} font-semibold whitespace-nowrap">${amountText}</span>` : `<span class="text-gray-400 text-xs whitespace-nowrap">—</span>`}
      </div>
    `;
    listEl.appendChild(li);
  }

  const amountRe = /\(\$[\d,]+\.\d{2}\)/;

  days.forEach(d => {
    const dayNum = d.date.getDate();

    // Income
    incomes
      .filter(i => occursOn(i, d.date))
      .forEach(i => {
        addRow(incomeEl, dayNum, i.name, money(i.amount), 'text-green-700');
      });
    // Cash / debit bills (red)
    expenses
      .filter(e => e && e.enabled !== false && occursOn(e, d.date) && (e.payMethod||'debit') !== 'credit')
      .forEach(e => {
        addRow(billsEl, dayNum, e.name, money(e.amount), 'text-red-700');
      });

    // Credit-card-paid bills (informational, purple)
    if(infoEl){
      expenses
        .filter(e => e && e.enabled !== false && occursOn(e, d.date) && (e.payMethod||'debit') === 'credit')
        .forEach(e => {
          infoTotal += Number(e.amount||0);
          addRow(infoEl, dayNum, e.name, money(e.amount), 'text-purple-700');
        });
    }

    // Credit card payments due (one line per card, red)
    const ccKey = formatDate(d.date);
    const ccBucket = (window.__ccBuckets && window.__ccBuckets[ccKey]) ? window.__ccBuckets[ccKey] : null;
    const ccCards = (ccBucket && ccBucket.byCard) ? Object.values(ccBucket.byCard) : [];
    ccCards
      .filter(c => Number(c.total||0) > 0)
      .sort((a,b)=>String(a.name||'').localeCompare(String(b.name||'')))
      .forEach(c => {
        addRow(billsEl, dayNum, `${c.name} payment due`, money(c.total), 'text-red-700');
      });
  });

  // Empty states
  if(!incomeEl.children.length){
    const li = document.createElement('li');
    li.className = 'px-3 py-3 text-sm text-gray-500';
    li.textContent = 'No future income in this month.';
    incomeEl.appendChild(li);
  }
  if(!billsEl.children.length){
    const li = document.createElement('li');
    li.className = 'px-3 py-3 text-sm text-gray-500';
    li.textContent = 'No future bills in this month.';
    billsEl.appendChild(li);
  }

  // Informational section footer + empty state
  if(infoEl){
    if(!infoEl.children.length){
      const li = document.createElement('li');
      li.className = 'px-3 py-3 text-sm text-gray-500';
      li.textContent = 'No informational items in this month.';
      infoEl.appendChild(li);
    }
  }
  if(infoTotalEl){
    infoTotalEl.textContent = money(infoTotal);
  }

  document.getElementById('monthModal').classList.remove('hidden');
}

function closeMonthModal(){ document.getElementById('monthModal').classList.add('hidden'); }

// ---------- Debt Planner Utilities ----------
function saveDebtsToStorage(){
  // Debts are saved per profile via saveData()
  saveData();
}
function saveDebtPlan(){
  // Debt plan is saved per profile via saveData()
  saveData();
}
function getStrategy(){
  return (document.querySelector('input[name="debtStrategy"]:checked')||{}).value || 'avalanche';
}
function monthlyRate(aprPct){
  const apr = (parseFloat(aprPct)||0)/100;
  return apr/12;
}
function addMonths(date, n){
  return new Date(date.getFullYear(), date.getMonth()+n, 1);
}

// ---------- Payoff Simulation ----------
function simulatePayoff(debtsInput, strategy, extraMonthly){
  const extraIsArray = Array.isArray(extraMonthly);
  const baseExtra = extraIsArray ? 0 : Math.max(0, parseFloat(extraMonthly)||0);
  const getExtraForMonth = (monthIndex)=>{
    if(extraIsArray){
      const v = extraMonthly[monthIndex];
      const n = Math.max(0, parseFloat(v)||0);
      return isFinite(n) ? n : 0;
    }
    return baseExtra;
  };

  const debtsSim = debtsInput
    .map(d=>({
      id: d.id,
      name: d.name || 'Debt',
      type: d.type || 'credit_card',
      balance: Math.max(0, parseFloat(d.balance)||0),
      apr: Math.max(0, parseFloat(d.apr)||0),
      minPayment: Math.max(0, parseFloat(d.minPayment)||0),
      order: parseInt(d.order||0,10)
    }))
    .filter(d=>d.balance > 0.00001);

  const schedule = [];
  let totalInterest = 0;
  let month = 0;
  const MAX_MONTHS = 600;

  if(debtsSim.length === 0){
    return {months:0, totalInterest:0, debtFreeDate:null, schedule:[]};
  }

  while(month < MAX_MONTHS){
    const remaining = debtsSim.filter(d=>d.balance > 0.00001);
    if(remaining.length === 0) break;

    const targetOrder = [...remaining].sort((a,b)=>{
      if(strategy === 'snowball') return a.balance - b.balance;
      if(strategy === 'avalanche') return b.apr - a.apr;
      return (a.order - b.order) || (b.apr - a.apr);
    });

    // 1) interest
    const monthInterestById = {};
    remaining.forEach(d=>{
      const interest = d.balance * monthlyRate(d.apr);
      d.balance += interest;
      monthInterestById[d.id] = interest;
      totalInterest += interest;
    });

    // 2) mins
    const payments = {};
    remaining.forEach(d=>{
      const pay = Math.min(d.minPayment, d.balance);
      d.balance -= pay;
      payments[d.id] = (payments[d.id]||0) + pay;
    });

    // 3) extra
    let extraLeft = getExtraForMonth(month);
    for(const t of targetOrder){
      if(extraLeft <= 0) break;
      if(t.balance <= 0.00001) continue;
      const pay = Math.min(extraLeft, t.balance);
      t.balance -= pay;
      payments[t.id] = (payments[t.id]||0) + pay;
      extraLeft -= pay;
    }

    schedule.push({
      monthIndex: month,
      interest: monthInterestById,
      payments,
      balances: debtsSim.reduce((acc,d)=>{ acc[d.id]=d.balance; return acc; }, {})
    });

    if(debtsSim.every(d=>d.balance <= 0.00001)){ month++; break; }
    month++;
  }

  const now = new Date();
  const base = new Date(now.getFullYear(), now.getMonth(), 1);
  const debtFreeDate = addMonths(base, month);
  return {months: month, totalInterest, debtFreeDate, schedule};
}

// ---------- Per-Debt Stats (debt-free date, months, interest) ----------
function computePerDebtStats(simResult, baseMonthDate){
  const base = baseMonthDate || new Date(new Date().getFullYear(), new Date().getMonth(), 1);
  const stats = {};
  const ids = new Set((debts||[]).map(d=>d.id));

  // Init
  ids.forEach(id=>{
    stats[id] = {months: null, debtFreeDate: null, totalInterest: 0};
  });

  const sched = simResult && simResult.schedule ? simResult.schedule : [];

  // Sum interest per debt
  sched.forEach((row, idx)=>{
    const intr = row.interest || {};
    Object.entries(intr).forEach(([id, val])=>{
      if(!stats[id]) stats[id] = {months:null, debtFreeDate:null, totalInterest:0};
      stats[id].totalInterest += (parseFloat(val)||0);
    });
  });

  // Find payoff month per debt (first month balance <= 0)
  for(const id of Object.keys(stats)){
    let payoffIdx = null;
    for(let i=0; i<sched.length; i++){
      const bal = (sched[i].balances && typeof sched[i].balances[id] !== 'undefined')
        ? parseFloat(sched[i].balances[id]) || 0
        : null;
      if(bal !== null && bal <= 0.00001){
        payoffIdx = i;
        break;
      }
    }

    // If never hits zero in schedule but original balance is already 0, treat as 0 months
    const orig = debts.find(d=>d.id===id);
    const origBal = Math.max(0, parseFloat(orig?.balance)||0);

    if(origBal <= 0.00001){
      stats[id].months = 0;
      stats[id].debtFreeDate = base;
    } else if(payoffIdx !== null){
      stats[id].months = payoffIdx + 1; // month indices start at 0
      stats[id].debtFreeDate = addMonths(base, payoffIdx);
    } else {
      stats[id].months = null;
      stats[id].debtFreeDate = null;
    }

    // If it doesn't pay off within the simulated schedule, treat summaries as blank
    if(stats[id].months === null && origBal > 0.00001){
      stats[id].totalInterest = null;
    } else {
      stats[id].totalInterest = parseFloat((stats[id].totalInterest||0).toFixed(2));
    }
  }

  return stats;
}

function formatMonthYear(d){
  if(!d) return '—';
  return d.toLocaleDateString(undefined, {month:'short', year:'numeric'});
}

function renderDebtModalStats(debtId){
  // IMPORTANT: while the debt edit modal is open, the user may be changing fields
  // that are not yet persisted back into `debts[]` until Save. So compute the
  // summary from the live modal inputs when possible.
  let debt = (debts||[]).find(d=>d.id===debtId);
  try{
    if(window.currentDebt && window.currentDebt.id === debtId){
      const balEl = document.getElementById('debtBalance');
      const aprEl = document.getElementById('debtApr');
      const pmtEl = document.getElementById('debtMinPayment');
      if(balEl && aprEl && pmtEl){
        debt = {
          ...(debt||{}),
          id: debtId,
          balance: parseFloat(balEl.value)||0,
          apr: parseFloat(aprEl.value)||0,
          minPayment: parseFloat(pmtEl.value)||0
        };
      }
    }
  }catch(e){}
  if(!debt) return;

  const now = new Date();
  const base = new Date(now.getFullYear(), now.getMonth(), 1);
  // Use the SAME payoff model as Plan Preview so the modal stats match:
  // running(next) = running + forecastedCharges + interest - (min + principalExtra)
  // (principalExtra comes from the per-debt principal schedule table).
  let tempDebt = {...(debt||{})};
  try{
    // If the principal schedule table is present, treat the current inputs as authoritative.
    const body = document.getElementById('debtPrincipalScheduleBody');
    if(body){
      tempDebt.principalSchedule = _mm_readDebtPrincipalScheduleFromModalInputs();
    }
  }catch(e){}

  const plan = _mm_computeDebtPlanStatsForDebt(tempDebt, base, 1200);
  let st;
  if(plan && plan.paidOff){
    st = {
      months: (typeof plan.months==='number') ? plan.months : 0,
      debtFreeDate: plan.payoffDate || null,
      totalInterest: (typeof plan.totalInterest==='number') ? plan.totalInterest : 0,
      warning: null,
      _includesPrincipal: true
    };
  } else {
    // Provide a useful warning rather than blank stats.
    const apr = Math.max(0, parseFloat(tempDebt?.apr)||0);
    const pmt = Math.max(0, parseFloat(tempDebt?.minPayment)||0);
    const bal0 = Math.max(0, parseFloat(tempDebt?.balance)||0);
    const monthKey = _mm_monthKeyFromYM(base.getFullYear(), base.getMonth()+1);
    const firstExtra = Math.max(0, Number(_mm_getPrincipalForDebtMonth(tempDebt, monthKey) || 0));
    const firstInterest = bal0 * (apr/100) / 12;

    let warning = 'Unable to compute payoff with the current inputs.';
    if(bal0 <= 0.00001){
      warning = null;
    } else if((pmt + firstExtra) <= 0){
      warning = 'Set a minimum payment (or principal schedule) to see payoff estimates.';
    } else if(apr>0 && (pmt + firstExtra) <= (firstInterest + 0.000001)){
      warning = 'Payment (minimum + scheduled principal) does not cover monthly interest — balance won\'t decrease.';
    }

    st = { months:null, debtFreeDate:null, totalInterest:null, warning, _includesPrincipal:true };
  }

  const debtFreeEl = document.getElementById('debtModalDebtFree');
  const monthsEl = document.getElementById('debtModalMonths');
  const intrEl = document.getElementById('debtModalInterest');
  const noteEl = document.getElementById('debtModalSummaryNote');

  // Use em-dash placeholders instead of empty strings so it doesn't look "broken".
  if(st && st.months === null){
    if(debtFreeEl) debtFreeEl.textContent = '—';
    if(monthsEl) monthsEl.textContent = '—';
    if(intrEl) intrEl.textContent = '—';
  } else {
    if(debtFreeEl) debtFreeEl.textContent = st.debtFreeDate ? formatMonthYear(st.debtFreeDate) : '—';
    if(monthsEl) monthsEl.textContent = (typeof st.months === 'number') ? `${st.months}` : '—';
    if(intrEl) intrEl.textContent = (typeof st.totalInterest === 'number') ? money(st.totalInterest) : '—';
  }

  if(noteEl){
    if(st.warning){
      noteEl.textContent = `⚠️ ${st.warning}`;
    } else {
      // If they have any principal plan rows, mention it so expectations match Plan Preview.
      let hasExtra = false;
      try{
        const map = tempDebt?.principalSchedule || {};
        hasExtra = Object.values(map).some(v => (Number(v)||0) > 0);
      }catch(e){}
      noteEl.textContent = hasExtra
        ? 'Estimates based on this debt’s APR + minimum payment + your principal schedule.'
        : 'Estimates based on this debt’s APR + minimum payment.';
    }
  }
}

function renderDebtPreviewStats(debtId){
  // Summary stats are computed inside openDebtPlanPreviewModal using the same roll-forward math as the table.
  // This function is kept for backward compatibility.
  return;
}

// ---------- Single-Debt Payoff Stats (independent of strategy) ----------
// Uses THIS debt's balance/APR/min payment only (no snowball/avalanche allocation).
function computeSingleDebtStats(debt, startDate){
  const d0 = debt || {};
  const bal0 = Math.max(0, parseFloat(d0.balance)||0);
  const apr = Math.max(0, parseFloat(d0.apr)||0);
  const pmt = Math.max(0, parseFloat(d0.minPayment)||0);

  const base = startDate || new Date(new Date().getFullYear(), new Date().getMonth(), 1);

  if(bal0 <= 0.00001){
    return { months: 0, debtFreeDate: base, totalInterest: 0, warning: null };
  }
  if(pmt <= 0){
    return { months: null, debtFreeDate: null, totalInterest: null, warning: 'Set a minimum payment to see payoff estimates.' };
  }

  const r = monthlyRate(apr);
  // If payment can't cover interest, it will never pay off.
  const firstInterest = bal0 * r;
  if(r > 0 && pmt <= firstInterest + 0.000001){
    return { months: null, debtFreeDate: null, totalInterest: null, warning: 'Payment does not cover monthly interest — balance won\'t decrease.' };
  }

  let remaining = bal0;
  let totalInterest = 0;
  let m = 0;
  const MAX_MONTHS = 1200;

  while(remaining > 0.00001 && m < MAX_MONTHS){
    const interest = remaining * r;
    totalInterest += interest;
    remaining += interest;

    const pay = Math.min(pmt, remaining);
    remaining -= pay;

    m++;
  }

  if(m >= MAX_MONTHS){
    return { months: null, debtFreeDate: null, totalInterest: parseFloat(totalInterest.toFixed(2)), warning: 'Payoff exceeded safety cap — check values.' };
  }

  return {
    months: m,
    debtFreeDate: addMonths(base, m-1),
    totalInterest: parseFloat(totalInterest.toFixed(2)),
    warning: null
  };
}

// ---------- Forecast Injection (per-debt expenses) ----------
function removeGeneratedDebtExpenses(){
  // Remove any previously injected debt-plan expenses from the expenses list.
  // We do this defensively so older injected items (e.g., from previous versions or changed due-day logic)
  // do not linger in the calendar/forecast.
  try{
    expenses = (expenses || []).filter(e => !(e && e._generatedByDebtPlan));
  }catch(err){}
  // Also clear the stored IDs list (used only for bookkeeping)
  try{
    if(debtPlan) debtPlan.generatedExpenseIds = [];
  }catch(err){}
}

// ---------- Auto CC Payment Bills (Statement + Extra) ----------
function removeGeneratedCCAutoBills(){
  try{
    expenses = (expenses || []).filter(e => !(e && e._generatedByCCAutoBills));
  }catch(err){}
}

function _mm_nextMonthlyDateForDay(day){
  // Returns the next date on/after today matching a day-of-month (1–28)
  const d = clamp(parseInt(day||1,10),1,28);
  const now = new Date();
  const y = now.getFullYear();
  const m = now.getMonth();
  const candidate = new Date(y, m, d);
  const today = new Date(y, m, now.getDate());
  return (candidate >= today) ? candidate : new Date(y, m+1, d);
}

function injectCCAutoBills(){
  try{
    const linked = new Set((debts||[]).map(x=>x && x.linkedCreditAccountId).filter(Boolean));
    const debitFallback = (typeof getDebitAccounts === 'function' && getDebitAccounts()[0]) ? getDebitAccounts()[0].id : null;
    const creditList = (typeof getCreditAccounts === 'function') ? getCreditAccounts() : (accounts||[]).filter(a=>a && a.type==='credit');

    const catId = ensureBillCategory('ccpay', 'Credit Card Payments');

    creditList.forEach(acc=>{
      if(!acc || !acc.id) return;

      // Skip cards that are already represented as a Debt (linked to a debt)
      if(linked.has(acc.id)) return;

      const stmt = Math.max(0, Number(acc.lastStatementBalance || 0));
      const cur  = Math.max(0, Number(acc.currentBalance || 0));
      const extra = Math.max(0, cur - stmt);

      const debitId = acc.payFromAccountId || debitFallback || null;
      const dueDay = clamp(parseInt(acc.dueDay || 1, 10), 1, 28);

      // First occurrence should be next due date from today
      const nextDue = (typeof computeNextDueDate === 'function')
        ? computeNextDueDate(new Date(), dueDay)
        : _mm_nextMonthlyDateForDay(dueDay);

      const startDate = formatDate(nextDue);

      if(stmt > 0.00001){
        expenses.push({
          id: `ccauto_${acc.id}_stmt`,
          name: `CC Payment • ${acc.name || 'Credit Card'} (Statement)`,
          amount: parseFloat(stmt.toFixed(2)),
          date: startDate,
          recurrence: 'once',
          payMethod: 'debit',
          debitAccountId: debitId,
          creditAccountId: null,
          categoryId: catId,
          _generatedByCCAutoBills: true,
          _ccAccountId: acc.id,
          _ccBillType: 'statement'
        });
      }

      if(extra > 0.00001){
        const extraDue = new Date(nextDue.getFullYear(), nextDue.getMonth()+1, nextDue.getDate());
        const extraStartDate = formatDate(extraDue);
        expenses.push({
          id: `ccauto_${acc.id}_extra`,
          name: `CC Payment • ${acc.name || 'Credit Card'} (Current Balance Extra)`,
          amount: parseFloat(extra.toFixed(2)),
          date: extraStartDate,
          recurrence: 'once',
          payMethod: 'debit',
          debitAccountId: debitId,
          creditAccountId: null,
          categoryId: catId,
          _generatedByCCAutoBills: true,
          _ccAccountId: acc.id,
          _ccBillType: 'extra'
        });
      }
    });
  }catch(err){}
}

function refreshAutoCCBills(){
  try{
    removeGeneratedCCAutoBills();
    injectCCAutoBills();
  }catch(e){}
}



function computeSweepExtrasFromForecast(buffer, months=12){
  // Iterative sweep:
  // 1) Compute the safe extra for Month 1 from the limiting low on/after payDay (minus buffer)
  // 2) Apply that extra as a cash-outflow on payDay (subtract from balances payDay..end)
  // 3) Repeat for Month 2, Month 3, ...
  try{
    const rowsSrc = (typeof dailyBalances !== 'undefined' && Array.isArray(dailyBalances)) ? dailyBalances :
                    (Array.isArray(window.dailyBalances) ? window.dailyBalances : []);
    if(!rowsSrc.length) return new Array(months).fill(0);

    const payDay = Number((debtPlan && debtPlan.payDay) || 1) || 1;

    // Working copy (we will adjust balances as we "apply" sweep payments month-by-month)
    const rows = rowsSrc
      .map(r=>{
        const d = r.date instanceof Date ? r.date : new Date(r.date);
        return { ...r, __dt: d, __bal: Number(r.balance) };
      })
      .filter(r=>r.__dt && !isNaN(r.__dt.getTime()) && isFinite(r.__bal))
      .sort((a,b)=>a.__dt - b.__dt);

    if(!rows.length) return new Array(months).fill(0);

    // Determine month keys present in forecast, in chronological order
    const monthKeys = [];
    const seen = new Set();
    rows.forEach(r=>{
      const k = r.__dt.getFullYear() + '-' + String(r.__dt.getMonth()+1).padStart(2,'0');
      if(!seen.has(k)){
        seen.add(k);
        monthKeys.push(k);
      }
    });

    const keys = monthKeys.slice(0, months);
    const extras = [];

    function monthKeyOf(d){
      return d.getFullYear() + '-' + String(d.getMonth()+1).padStart(2,'0');
    }
    function payDateForKey(key){
      const [yy, mm] = key.split('-').map(x=>parseInt(x,10));
      // payDay is 1–28 in UI; still clamp defensively.
      const dd = Math.max(1, Math.min(28, payDay));
      return new Date(yy, mm-1, dd);
    }

    for(let i=0;i<keys.length;i++){
      const key = keys[i];
      const pd = payDateForKey(key);

      let overallMin = Infinity;
      let postPayMin = Infinity;

      for(const r of rows){
        if(monthKeyOf(r.__dt) !== key) continue;
        overallMin = Math.min(overallMin, r.__bal);
        if(r.__dt.getDate() >= payDay){
          postPayMin = Math.min(postPayMin, r.__bal);
        }
      }

      if(!isFinite(overallMin)) overallMin = 0;
      if(!isFinite(postPayMin)) postPayMin = overallMin;

      const limitingLow = postPayMin; // IMPORTANT: limiting range is on/after payDay
      const extra = Math.max(0, limitingLow - (Number(buffer)||0));
      extras.push(extra);

      if(extra > 0){
        // Apply this month's sweep payment to all balances on/after the pay date
        for(const r of rows){
          if(r.__dt >= pd){
            r.__bal -= extra;
          }
        }
      }
    }

    while(extras.length < months) extras.push(0);
    return extras;
  }catch(e){
    return new Array(months).fill(0);
  }
}

function injectDebtPlanExpenses(simResult){
  // Generates calendar-visible "Debt Payment • ..." one-time expenses for the next 5 years.
  // Rules:
  //  - Minimum payment is always scheduled on the CREDIT CARD DUE DAY (if linked) or the debt pay day otherwise.
  //  - Per-debt principal schedule amounts are scheduled on that debt's payDay (1–28).
  //  - If min + principal fall on the same day, they are combined into one expense.
  const now = new Date();
  const startMonth = new Date(now.getFullYear(), now.getMonth(), 1);
  const monthsToInject = 60;

  const ids = [];

  const fallbackDebitId = (getDebitAccounts()[0]||{}).id || null;

  (debts||[]).forEach(debt=>{
    if(!debt || debt.enabled === false) return;

    const debtId = debt.id;
    const debtName = debt.name || 'Debt';

    // If this debt is linked to a credit card account, use that account's due day and pay-from debit account.
    let linkedAcc = null;
    try{ linkedAcc = (typeof _mm_getLinkedCreditAccountForDebt==='function') ? _mm_getLinkedCreditAccountForDebt(debt) : null; }catch(e){ linkedAcc = null; }

    const minPayment = Math.max(0, parseFloat(debt.minPayment)||0);

    
    const _mm_stmtBal = linkedAcc ? Math.max(0, parseFloat(linkedAcc.lastStatementBalance || 0) || 0) : 0;
    // User rule: if this debt is linked to a credit card account, do NOT post the minimum payment when last statement balance is 0.
    const _mm_minForMonth = linkedAcc ? (((_mm_stmtBal > 0) || (Math.max(0, parseFloat(debt.balance)||0) > 0)) ? minPayment : 0) : minPayment;
const dueDay = clamp(parseInt((linkedAcc && linkedAcc.dueDay) ? linkedAcc.dueDay : (debt.dueDay || debtPlan.payDay || 1), 10), 1, 28);
    const principalDay = dueDay;

    const debitId = (linkedAcc && linkedAcc.payFromAccountId) ? linkedAcc.payFromAccountId : fallbackDebitId;

    
    // --- Stop injecting payments after debt is paid off (close-out behavior) ---
    let _mm_runningBal = Math.max(0, parseFloat(debt.balance)||0);
    function _mm_sumLinkedCreditChargesForMonth(creditAccountId, monthBase){
      try{
        if(!creditAccountId) return 0;
        const y = monthBase.getFullYear();
        const mo = monthBase.getMonth();
        const start = new Date(y, mo, 1);
        const end = new Date(y, mo+1, 1);
        let total = 0;
        for(let d = new Date(start); d < end; d.setDate(d.getDate()+1)){
          (expenses||[]).forEach(e=>{
            if(!e || e.enabled === false) return;
            if(e._generatedByDebtPlan) return; // ignore our injected payments
            if((e.payMethod||'debit') !== 'credit') return;
            if(e.creditAccountId !== creditAccountId) return;
            if(!occursOn(e, d)) return;
            if(isPaidOccurrence(d, e.id)) return;
            total += Math.max(0, parseFloat(e.amount)||0);
          });
        }
        return total;
      }catch(err){
        return 0;
      }
    }
for(let m=0; m<monthsToInject; m++){
      const monthBase = new Date(startMonth.getFullYear(), startMonth.getMonth()+m, 1);

      // If this debt is already paid off, stop injecting future payments.
      if(_mm_runningBal <= 0.00001){
        _mm_runningBal = 0;
        break;
      }

      const dueDate = new Date(monthBase.getFullYear(), monthBase.getMonth(), dueDay);
      const principalDate = new Date(monthBase.getFullYear(), monthBase.getMonth(), principalDay);

      const monthKey = (typeof _mm_monthKeyFromYM === 'function')
        ? _mm_monthKeyFromYM(monthBase.getFullYear(), monthBase.getMonth()+1)
        : `${monthBase.getFullYear()}-${String(monthBase.getMonth()+1).padStart(2,'0')}`;

      const principalAmt = (typeof _mm_getPrincipalForMonth === 'function')
        ? _mm_getPrincipalForMonth(debt, monthKey)
        : 0;

      // If min & principal are on same date, combine.
      if(formatDate(dueDate) === formatDate(principalDate)){
        const combined = (_mm_minForMonth||0) + (principalAmt||0);
        if(combined > 0){
          const id = `dp_${debtId}_${formatDate(dueDate)}_combined`;
          if(!ids.includes(id)){
            ids.push(id);
            expenses.push({
              id,
              name: `Debt Payment • ${debtName}`,
              amount: parseFloat(combined.toFixed(2)),
              date: formatDate(dueDate),
              recurrence: 'once',
              n: 1,
              payMethod: 'debit',
              debitAccountId: debitId,
              creditAccountId: null,
              _generatedByDebtPlan: true,
              _debtId: debtId,
              categoryId: ensureBillCategory('debt', 'Debt Payments'),
              _displayPayMethod: (linkedAcc ? 'credit' : 'debit'),
              _linkedCreditAccountId: (linkedAcc ? linkedAcc.id : null),
              _linkedCreditAccountName: (linkedAcc ? linkedAcc.name : null)
            });
          }
        }
      } else {
        if((_mm_minForMonth||0) > 0){
          const idMin = `dp_${debtId}_${formatDate(dueDate)}_min`;
          if(!ids.includes(idMin)){
            ids.push(idMin);
            expenses.push({
              id: idMin,
              name: `Debt Payment • ${debtName} (Minimum)`,
              amount: parseFloat((_mm_minForMonth||0).toFixed(2)),
              date: formatDate(dueDate),
              recurrence: 'once',
              n: 1,
              payMethod: 'debit',
              debitAccountId: debitId,
              creditAccountId: null,
              _generatedByDebtPlan: true,
              _debtId: debtId,
              categoryId: ensureBillCategory('debt', 'Debt Payments'),
              _displayPayMethod: (linkedAcc ? 'credit' : 'debit'),
              _linkedCreditAccountId: (linkedAcc ? linkedAcc.id : null),
              _linkedCreditAccountName: (linkedAcc ? linkedAcc.name : null)
            });
          }
        }
        if(principalAmt > 0){
          const idP = `dp_${debtId}_${formatDate(principalDate)}_principal`;
          if(!ids.includes(idP)){
            ids.push(idP);
            expenses.push({
              id: idP,
              name: `Debt Payment • ${debtName} (Principal)`,
              amount: parseFloat(principalAmt.toFixed(2)),
              date: formatDate(principalDate),
              recurrence: 'once',
              n: 1,
              payMethod: 'debit',
              debitAccountId: debitId,
              creditAccountId: null,
              _generatedByDebtPlan: true,
              _debtId: debtId,
              categoryId: ensureBillCategory('debt', 'Debt Payments'),
              _displayPayMethod: (linkedAcc ? 'credit' : 'debit'),
              _linkedCreditAccountId: (linkedAcc ? linkedAcc.id : null),
              _linkedCreditAccountName: (linkedAcc ? linkedAcc.name : null)
            });
          }
        }
      }

      // Roll forward a simple payoff balance to decide whether to keep injecting payments in future months.
      // Close-out rule: once paid off, stop injecting future minimum/principal payments.
      try{
        const chargesThisMonth = (linkedAcc && linkedAcc.id) ? _mm_sumLinkedCreditChargesForMonth(linkedAcc.id, monthBase) : 0;
        _mm_runningBal += chargesThisMonth;
        const interest = _mm_runningBal * (Math.max(0, parseFloat(debt.apr)||0) / 100) / 12;
        const owed = _mm_runningBal + interest;
        const planned = Math.max(0, (_mm_minForMonth||0)) + Math.max(0, (principalAmt||0));
        const pay = Math.min(owed, planned);
        _mm_runningBal = Math.max(0, owed - pay);
      }catch(e){}

    }
  });

  debtPlan.generatedExpenseIds = ids;
}

// ---------- Warnings ----------
function updateDebtWarnings(){
  const warnEl = document.getElementById('debtWarnings');
  if(!warnEl) return;

  if(!debtPlan.applyToForecast){
    warnEl.classList.add('hidden');
    warnEl.textContent = '';
    return;
  }

  if(!dailyBalances || dailyBalances.length===0){
    warnEl.classList.add('hidden');
    return;
  }

  let lowest = Infinity;
  let lowestDate = null;
  let firstNegative = null;

  dailyBalances.forEach(d=>{
    if(d.balance < lowest){
      lowest = d.balance;
      lowestDate = d.date;
    }
    if(firstNegative === null && d.balance < 0){
      firstNegative = d.date;
    }
  });

  if(firstNegative){
    warnEl.classList.remove('hidden');
    warnEl.className = 'p-3 rounded-lg border text-sm bg-red-50 border-red-200 text-red-700';
    warnEl.innerHTML = `
      <div class="font-semibold">⚠️ Plan may overdraw your cash</div>
      <div class="mt-1">Your forecast goes negative on <span class="font-semibold">${firstNegative.toLocaleDateString()}</span>.</div>
      <div class="mt-1 text-xs">Try lowering “Extra Monthly Payment”, changing payment day, or switching strategy.</div>
    `;
  } else {
    warnEl.classList.remove('hidden');
    warnEl.className = 'p-3 rounded-lg border text-sm bg-green-50 border-green-200 text-green-700';
    warnEl.innerHTML = `
      <div class="font-semibold">✅ Plan fits your cash forecast</div>
      <div class="mt-1">Lowest forecasted balance: <span class="font-semibold">${money(lowest)}</span>${lowestDate ? ` on ${lowestDate.toLocaleDateString()}` : ''}.</div>
    `;
  }
}

// ---------- Debt UI (list + modal) ----------
function addDebt(){
  // Create a draft debt but DO NOT persist until user clicks Save
  const id = uuid();
  const draft = {
    id,
    name: 'New Debt',
    type: 'credit_card',
    balance: 0,
    apr: 0,
    minPayment: 0,
    order: debts.length
  };

  // Track draft (not added to debts array yet)
  window.__debtDraft = draft;
  currentDebt = {id, isNew:true};

  // Populate modal fields from draft
  document.getElementById('debtName').value = draft.name || '';
  document.getElementById('debtType').value = draft.type || 'credit_card';
  document.getElementById('debtBalance').value = draft.balance || 0;
  document.getElementById('debtApr').value = draft.apr || 0;
  document.getElementById('debtMinPayment').value = draft.minPayment || 0;
  document.getElementById('debtDueDay').value = (draft.dueDay || debtPlan.payDay || 1);

  // Linked credit card selector
  try{ _mm_renderDebtLinkedCreditAccountSelect(draft); }catch(e){}

  // Hide delete button for new (unsaved) debts
  const delBtn = document.querySelector('#debtModal button[onclick="deleteDebtModal()"]');
  if(delBtn) delBtn.style.display = 'none';

  // Render per-debt stats in modal for draft values
  renderDebtModalStats(id);

  try{ _mm_renderDebtPrincipalScheduleTable(draft); }catch(e){}

  document.getElementById('debtModal').classList.remove('hidden');
}

function openDebtModal(id){
  // Editing an existing saved debt
  currentDebt = {id, isNew:false};
  window.__debtDraft = null;

  const d = debts.find(x=>x.id===id);
  if(!d) return;

  document.getElementById('debtName').value = d.name || '';
  document.getElementById('debtType').value = d.type || 'credit_card';
  document.getElementById('debtBalance').value = d.balance || 0;
  document.getElementById('debtApr').value = d.apr || 0;
  document.getElementById('debtMinPayment').value = d.minPayment || 0;
  document.getElementById('debtDueDay').value = (d.dueDay || debtPlan.payDay || 1);

  // Linked credit card selector
  try{ _mm_renderDebtLinkedCreditAccountSelect(d); }catch(e){}

  // Show delete button for existing debts
  const delBtn = document.querySelector('#debtModal button[onclick="deleteDebtModal()"]');
  if(delBtn) delBtn.style.display = 'inline-flex';

  renderDebtModalStats(id);

  try{ _mm_renderDebtPrincipalScheduleTable(d); }catch(e){}

    _mm_applyDebtDueDayLinkingLock();
document.getElementById('debtModal').classList.remove('hidden');
}
function closeDebtModal(){
  // If user cancels a NEW (unsaved) debt, discard draft
  if(currentDebt && currentDebt.isNew){
    window.__debtDraft = null;
  }
  currentDebt = null;
  document.getElementById('debtModal').classList.add('hidden');
}

// Live-update the modal payoff summary while the user edits fields
(function _mm_hookDebtModalLiveStats(){
  try{
    const ids = ['debtBalance','debtApr','debtMinPayment'];
    ids.forEach(id=>{
      const el = document.getElementById(id);
      if(!el) return;
      if(el._mm_liveStatsBound) return;
      el._mm_liveStatsBound = true;
      el.addEventListener('input', ()=>{
        try{ if(window.currentDebt && window.currentDebt.id) renderDebtModalStats(window.currentDebt.id); }catch(e){}
      });
      el.addEventListener('change', ()=>{
        try{ if(window.currentDebt && window.currentDebt.id) renderDebtModalStats(window.currentDebt.id); }catch(e){}
      });
    });
  }catch(e){}
})();


  function _mm_applyDebtDueDayLinkingLock() {
    // This app's debt modal uses id="debtLinkedCreditAccount" for the credit-card link select.
    const sel =
      document.getElementById('debtLinkedCreditAccount') ||
      document.getElementById('debtLinkedAccount') ||
      document.querySelector('#debtLinkedCreditWrap select');

    const dueInp = document.getElementById('debtDueDay');
    if (!dueInp) return;

    const linkedId = sel ? (sel.value || '') : '';
    if (!linkedId) {
      // no link: unlock
      dueInp.disabled = false;
      dueInp.classList.remove('mm-disabled');
      return;
    }

    // find linked account
    const acc = (accounts || []).find(a => a && String(a.id) === String(linkedId));
    // lock only when the linked account is a CREDIT account (credit card)
    const isCredit = acc && (acc.type === 'credit' || acc.type === 'creditcard' || acc.kind === 'credit');
    if (!isCredit) {
      dueInp.disabled = false;
      dueInp.classList.remove('mm-disabled');
      return;
    }

    const ccDueDay = Number(acc.dueDay || acc.ccDueDay || acc.paymentDueDay || 1) || 1;
    dueInp.value = String(ccDueDay);
    dueInp.disabled = true;
    dueInp.classList.add('mm-disabled');
  }

  function saveDebtModal(){
  
    _mm_applyDebtDueDayLinkingLock();
if(!currentDebt) return;

  // If this is a NEW debt, create it now from the draft
  let d = debts.find(x=>x.id===currentDebt.id);
  if(!d){
    if(currentDebt.isNew && window.__debtDraft && window.__debtDraft.id===currentDebt.id){
      d = {...window.__debtDraft};
      debts.push(d);
      window.__debtDraft = null;
    } else {
      return;
    }
  }

  d.name = document.getElementById('debtName').value || 'Debt';
  d.type = document.getElementById('debtType').value || 'credit_card';
  d.balance = parseFloat(document.getElementById('debtBalance').value)||0;
  d.apr = parseFloat(document.getElementById('debtApr').value)||0;
  d.minPayment = parseFloat(document.getElementById('debtMinPayment').value)||0;
  d.dueDay = clamp(parseInt(document.getElementById('debtDueDay')?.value || (d.dueDay||debtPlan.payDay||1), 10), 1, 28);
  // Keep backward-compatibility: treat payDay as the debt's payment day too.
  d.payDay = d.dueDay;
  // Linked account (optional)
  try{
    const sel = document.getElementById('debtLinkedCreditAccount');
    const linkedId = sel ? (sel.value||'') : '';
    d.linkedCreditAccountId = linkedId ? linkedId : null;

    if(d.linkedCreditAccountId){
      const acc = (accounts||[]).find(a=>a && a.id===d.linkedCreditAccountId);
      // Only "sync" balance / due-day when this is a credit-card debt linked to a CREDIT account.
      if(acc && d.type==='credit_card' && acc.type==='credit'){
        d.balance = Number(acc.currentBalance||0) || 0;

        // If linked, default the due day to the card's due day ONLY when the user hasn't set one.
        const linkedDue = Number(acc.dueDay || acc.ccDueDay || acc.paymentDueDay || 0) || 0;
        if((!d.dueDay || !isFinite(d.dueDay)) && linkedDue>=1 && linkedDue<=28){
          d.dueDay = linkedDue;
          d.payDay = linkedDue;
        }
      }
      // For loans (or non-credit link targets), we simply store the link id and do not override fields.
    }
  }catch(e){}
try{ _mm_saveDebtPrincipalScheduleFromModal(d); }catch(e){}
  saveDebtsToStorage();
  renderDebtPlanner();
  closeDebtModal();
}
function deleteDebtModal(){
  if(!currentDebt) return;

  // If it's a new (unsaved) debt, just close and discard the draft
  if(currentDebt.isNew){
    window.__debtDraft = null;
    closeDebtModal();
    return;
  }

  debts = debts.filter(x=>x.id!==currentDebt.id);
  saveDebtsToStorage();
  renderDebtPlanner();
  closeDebtModal();
}

// ---------- Custom Order Drag & Drop ----------
function normalizeDebtOrder(){
  const sorted = [...debts].sort((a,b)=>(a.order||0)-(b.order||0));
  sorted.forEach((d, idx)=> d.order = idx);
  saveDebtsToStorage();
}

function renderCustomOrder(){
  const card = document.getElementById('customOrderCard');
  const list = document.getElementById('customOrderList');
  if(!card || !list) return;

  const strategy = getStrategy();
  if(strategy !== 'custom'){
    card.classList.add('hidden');
    return;
  }
  card.classList.remove('hidden');

  const sorted = [...debts].sort((a,b)=>(a.order||0)-(b.order||0));
  list.innerHTML = '';

  sorted.forEach((d, idx)=>{
    const row = document.createElement('div');
    row.className = 'p-3 border rounded-lg bg-gray-50 flex items-center justify-between gap-3';
    row.draggable = true;
    row.dataset.debtId = d.id;

    row.innerHTML = `
      <div class="flex items-center gap-3">
        <div class="text-gray-400 select-none">☰</div>
        <div>
          <div class="font-semibold">${d.name || 'Debt'}</div>
          <div class="text-xs text-gray-500">Order: ${idx+1} • Balance: ${money(d.balance||0)}</div>
        </div>
      </div>
      <button class="text-sm text-blue-600" onclick="openDebtModal('${d.id}')">Edit</button>
    `;

    row.addEventListener('dragstart', (e)=>{
      e.dataTransfer.setData('text/plain', d.id);
      row.classList.add('opacity-60');
    });
    row.addEventListener('dragend', ()=>{
      row.classList.remove('opacity-60');
    });
    row.addEventListener('dragover', (e)=>{
      e.preventDefault();
      row.classList.add('ring-2','ring-blue-300');
    });
    row.addEventListener('dragleave', ()=>{
      row.classList.remove('ring-2','ring-blue-300');
    });
    row.addEventListener('drop', (e)=>{
      e.preventDefault();
      row.classList.remove('ring-2','ring-blue-300');

      const draggedId = e.dataTransfer.getData('text/plain');
      const targetId = d.id;
      if(!draggedId || draggedId === targetId) return;

      const arr = [...debts].sort((a,b)=>(a.order||0)-(b.order||0));
      const fromIdx = arr.findIndex(x=>x.id===draggedId);
      const toIdx = arr.findIndex(x=>x.id===targetId);
      if(fromIdx < 0 || toIdx < 0) return;

      const [moved] = arr.splice(fromIdx, 1);
      arr.splice(toIdx, 0, moved);

      arr.forEach((x,i)=> x.order = i);
      saveDebtsToStorage();
      renderDebtPlanner();
    });

    list.appendChild(row);
  });
}

// ---------- Debt Plan Preview Modal (per debt) ----------

// --- Debt plan preview math helpers (shared by planner + preview modal) ---
function _mm_sumCreditChargesForMonth(creditAccountId, monthDate){
  // Sum forecasted charges for the given credit card for that month
  // Uses existing recurrence + paid-occurrence logic.
  try{
    if(!creditAccountId) return 0;
    const monthStart = new Date(monthDate.getFullYear(), monthDate.getMonth(), 1);
    const totalDays = new Date(monthStart.getFullYear(), monthStart.getMonth()+1, 0).getDate();
    let total = 0;

    for(let day=1; day<=totalDays; day++){
      const d = new Date(monthStart.getFullYear(), monthStart.getMonth(), day);
      (expenses||[]).forEach(e=>{
        if(!e) return;
        if(e.enabled === false) return;
        if(e.payMethod !== 'credit') return;
        if(e.creditAccountId !== creditAccountId) return;
        if(typeof occursOn === 'function' && !occursOn(e, d)) return;
        if(typeof isPaidOccurrence === 'function' && isPaidOccurrence(d, e.id)) return;
        const amt = Math.max(0, parseFloat(e.amount)||0);
        total += amt;
      });
    }
    return total;
  }catch(e){
    return 0;
  }
}

function _mm_computeDebtPlanStatsForDebt(debt, baseDate, maxMonths){
  // Matches the logic used by the Plan Preview modal:
  // running(next) = running + forecastedCharges + interest - (min + principalExtra)
  if(!debt) return { paidOff:false, months:null, payoffDate:null, totalInterest:null };

  const apr = Math.max(0, Number(debt.apr||0));
  const minPaymentCfg = Math.max(0, Number(debt.minPayment||0));
  let running = Math.max(0, Number(debt.balance||0));
  let totalInterest = 0;

  const base = new Date(baseDate.getFullYear(), baseDate.getMonth(), 1);
  const limit = Math.max(1, Math.min(1200, Number(maxMonths||600)));

  if(running <= 0.000001){
    return { paidOff:true, months:0, payoffDate:new Date(base), totalInterest:0 };
  }

  for(let i=0; i<limit; i++){
    const when = addMonths(base, i);

    // Add forecasted charges for linked credit cards
    if(debt && debt.linkedCreditAccountId){
      running += _mm_sumCreditChargesForMonth(debt.linkedCreditAccountId, when);
    }

    const interestAdded = running * (apr/100) / 12;
    totalInterest += interestAdded;

    const monthKey = _mm_monthKeyFromYM(when.getFullYear(), when.getMonth()+1);
    const extraPay = Math.max(0, Number(_mm_getPrincipalForDebtMonth(debt, monthKey) || 0));
    const plannedPay = minPaymentCfg + extraPay;

    const owed = running + interestAdded;

    // If you pay nothing while balance is positive, it will never pay off in this model.
    if(plannedPay <= 0 && owed > 0){
      return { paidOff:false, months:null, payoffDate:null, totalInterest:null };
    }

    const actualPay = Math.min(owed, Math.max(0, plannedPay));
    running = Math.max(0, owed - actualPay);

    // If paid off, close out: keep at $0 and stop previewing further months
    if(running <= 0.00001){
      running = 0;
    }

    if(running <= 0.000001){
      return {
        paidOff:true,
        months:i+1,
        payoffDate:new Date(when),
        totalInterest: parseFloat((totalInterest||0).toFixed(2))
      };
    }
  }

  return { paidOff:false, months:null, payoffDate:null, totalInterest:null };
}

function _mm_computeDebtPlannerSummaryStats(){
  const list = Array.isArray(debts) ? debts : [];
  if(list.length===0) return { ok:false, debtFreeDate:null, months:null, totalInterest:null };

  const now = new Date();
  const base = new Date(now.getFullYear(), now.getMonth(), 1);
  let latestPayoff = null;
  let maxMonths = 0;
  let sumInterest = 0;

  for(const d of list){
    const s = _mm_computeDebtPlanStatsForDebt(d, base, 600);
    if(!s.paidOff){
      return { ok:false, debtFreeDate:null, months:null, totalInterest:null };
    }
    if(s.months !== null) maxMonths = Math.max(maxMonths, s.months);
    if(typeof s.totalInterest === 'number') sumInterest += s.totalInterest;
    if(s.payoffDate){
      if(!latestPayoff || s.payoffDate > latestPayoff) latestPayoff = s.payoffDate;
    }
  }
  return { ok:true, debtFreeDate:latestPayoff, months:maxMonths, totalInterest: parseFloat((sumInterest||0).toFixed(2)) };
}
// --- end helpers ---

function openDebtPlanPreviewModal(debtId){
  try{ syncLinkedCreditCardDebtBalances(); }catch(e){}

  const debt = (debts||[]).find(d=>d.id===debtId);
  const debtName = debt && debt.name ? debt.name : 'Debt';
  const titleEl = document.getElementById('debtPlanPreviewTitle');
  if(titleEl) titleEl.textContent = `Plan Preview • ${debtName}`;

  const debtFreeEl = document.getElementById('debtPreviewDebtFree');
  const monthsEl = document.getElementById('debtPreviewMonths');
  const intrEl = document.getElementById('debtPreviewInterest');
  const noteEl = document.getElementById('debtPreviewNote');

  // Reset stats while we compute (use placeholders so it doesn't look "broken")
  if(debtFreeEl) debtFreeEl.textContent = '—';
  if(monthsEl) monthsEl.textContent = '—';
  if(intrEl) intrEl.textContent = '—';
  if(noteEl) noteEl.textContent = '';

  // Safety
  const apr = Math.max(0, parseFloat(debt?.apr)||0);
  const minPaymentCfg = Math.max(0, parseFloat(debt?.minPayment)||0);
  const startBalance = Math.max(0, parseFloat(debt?.balance)||0);

  const now = new Date();
  const base = new Date(now.getFullYear(), now.getMonth(), 1);

  // Helper: sum forecasted credit charges on a linked CC for a given month (future occurrences only, unpaid only)
  function sumCreditChargesForMonth(creditAccountId, monthDate){
    try{
      if(!creditAccountId) return 0;
      const y = monthDate.getFullYear();
      const m = monthDate.getMonth();
      const start = new Date(y, m, 1);
      const end = new Date(y, m+1, 1);
      let total = 0;

      for(let d = new Date(start); d < end; d.setDate(d.getDate()+1)){
        (expenses||[]).forEach(e=>{
          if(!e || e.enabled === false) return;
          if((e.payMethod||'debit') !== 'credit') return;
          if(e.creditAccountId !== creditAccountId) return;
          if(!occursOn(e, d)) return;
          if(isPaidOccurrence(d, e.id)) return;
          const amt = Math.max(0, parseFloat(e.amount)||0);
          total += amt;
        });
      }
      return total;
    }catch(err){
      return 0;
    }
  }

  const modal = document.getElementById('debtPlanPreviewModal');
  const tbody = document.getElementById('debtPlanPreviewBody');
  if(!tbody){
    if(modal) modal.classList.remove('hidden');
    return;
  }
  tbody.innerHTML = '';

  // Build the 5-year table
  let running = startBalance;
  let totalInterest12 = 0;

  for(let i=0; i<60; i++){
    const when = addMonths(base, i);

    // Add forecasted charges for linked credit cards
    let monthCharges = 0;
    if(debt && debt.linkedCreditAccountId){
      monthCharges = sumCreditChargesForMonth(debt.linkedCreditAccountId, when);
      running += monthCharges;
    }

    const interestAdded = running * (apr/100) / 12;
    totalInterest12 += interestAdded;

    const monthKey = _mm_monthKeyFromYM(when.getFullYear(), when.getMonth()+1);
    const extraPay = debt ? Math.max(0, _mm_getPrincipalForDebtMonth(debt, monthKey) || 0) : 0;

    // Apply payments (cap at amount owed this month)
    const plannedPay = minPaymentCfg + extraPay;
    const owed = running + interestAdded;
    const actualPay = Math.min(owed, Math.max(0, plannedPay));

    running = Math.max(0, owed - actualPay);

    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td class="p-2">${formatMonthYear(when)}</td>
      <td class="p-2 text-right">${money(minPaymentCfg)}</td>
      <td class="p-2 text-right">${money(extraPay)}</td>
      <td class="p-2 text-right">${money(interestAdded)}</td>
      <td class="p-2 text-right">${money(running)}</td>
    `;
    tbody.appendChild(tr);
    if(running <= 0.00001){
      running = 0;
      break;
    }
  }

  // Compute payoff stats using the SAME roll-forward logic, extending beyond 12 months if needed
  let payoffRunning = startBalance;
  let payoffInterest = 0;
  let payoffMonthIndex = null;

  const MAX_MONTHS = 600; // 50 years cap
  for(let i=0; i<MAX_MONTHS; i++){
    const when = addMonths(base, i);

    if(debt && debt.linkedCreditAccountId){
      payoffRunning += sumCreditChargesForMonth(debt.linkedCreditAccountId, when);
    }

    const interestAdded = payoffRunning * (apr/100) / 12;
    payoffInterest += interestAdded;

    const monthKey = _mm_monthKeyFromYM(when.getFullYear(), when.getMonth()+1);
    const extraPay = debt ? Math.max(0, _mm_getPrincipalForDebtMonth(debt, monthKey) || 0) : 0;

    const plannedPay = minPaymentCfg + extraPay;
    const owed = payoffRunning + interestAdded;

    // If you pay nothing and charges keep coming, this may never pay off — bail out cleanly
    if(plannedPay <= 0 && owed > 0){
      payoffMonthIndex = null;
      break;
    }

    const actualPay = Math.min(owed, Math.max(0, plannedPay));
    payoffRunning = Math.max(0, owed - actualPay);

    if(payoffRunning <= 0.00001){
      payoffMonthIndex = i;
      break;
    }
  }

  if(payoffMonthIndex !== null){
    const payoffDate = addMonths(base, payoffMonthIndex);
    if(debtFreeEl) debtFreeEl.textContent = formatMonthYear(payoffDate);
    if(monthsEl) monthsEl.textContent = `${payoffMonthIndex+1}`;
    if(intrEl) intrEl.textContent = money(payoffInterest);
    if(noteEl) noteEl.textContent = 'Estimates based on this debt’s APR + minimum payment + your principal schedule.';
  }else{
    if(debtFreeEl) debtFreeEl.textContent = '—';
    if(monthsEl) monthsEl.textContent = '—';
    if(intrEl) intrEl.textContent = '—';

    // Provide a helpful reason when we can't compute a payoff
    let msg = '⚠️ Could not compute a payoff date (check minimum payment, extra principal schedule, APR, and any linked card charges).';
    try{
      const firstInterest = startBalance * (apr/100) / 12;
      const firstExtra = debt ? Math.max(0, _mm_getPrincipalForDebtMonth(debt, _mm_monthKeyFromYM(base.getFullYear(), base.getMonth()+1)) || 0) : 0;
      const firstPlanned = minPaymentCfg + firstExtra;
      if(firstPlanned <= 0){
        msg = '⚠️ Set a minimum payment (or add extra principal) to see payoff estimates.';
      } else if(apr > 0 && firstPlanned <= firstInterest + 0.000001){
        msg = '⚠️ Payment does not cover monthly interest — balance won\'t decrease.';
      } else if(debt && debt.linkedCreditAccountId){
        msg = '⚠️ Forecasted card charges may prevent payoff (or push it beyond the safety cap).';
      }
    }catch(e){}
    if(noteEl) noteEl.textContent = msg;
  }

  if(modal) modal.classList.remove('hidden');
}
function closeDebtPlanPreviewModal(){
  document.getElementById('debtPlanPreviewModal').classList.add('hidden');
}

// ---------- Principal Payment Schedule (per month) ----------
function _mm_getPrincipalScheduleStore(){
  if(!debtPlan) debtPlan = {};
  if(!debtPlan.principalSchedule || typeof debtPlan.principalSchedule !== 'object'){
    debtPlan.principalSchedule = {}; // monthKey -> number
  }
  return debtPlan.principalSchedule;
}

function _mm_monthKeysNext12(){
  const out = [];
  try{
    const byMonth = (typeof _mm_groupDailyBalancesByMonth === 'function') ? _mm_groupDailyBalancesByMonth() : {};
    const keys = Object.keys(byMonth||{}).sort();
    if(keys.length){
      // Use first month present in forecast
      const firstDt = byMonth[keys[0]] && byMonth[keys[0]][0] ? byMonth[keys[0]][0].__dt : null;
      const start = firstDt ? new Date(firstDt.getFullYear(), firstDt.getMonth(), 1) : new Date();
      for(let i=0; i<60; i++){
        const d = new Date(start.getFullYear(), start.getMonth()+i, 1);
        out.push(_mm_monthKey(d));
      }
      return out;
    }
  }catch(e){}
  const now = new Date();
  const start = new Date(now.getFullYear(), now.getMonth(), 1);
  for(let i=0; i<60; i++){
    const d = new Date(start.getFullYear(), start.getMonth()+i, 1);
    out.push(_mm_monthKey(d));
  }
  return out;
}

function _mm_monthLabelFromKey(key){
  try{
    const [yy, mm] = key.split('-').map(n=>parseInt(n,10));
    const d = new Date(yy, (mm||1)-1, 1);
    return d.toLocaleDateString(undefined, {month:'short', year:'numeric'});
  }catch(e){
    return key;
  }
}

function openPrincipalScheduleForPreviewDebt(){
  renderPrincipalScheduleTable();
  document.getElementById('principalScheduleModal')?.classList.remove('hidden');
}
function closePrincipalScheduleModal(){
  document.getElementById('principalScheduleModal')?.classList.add('hidden');
}

function renderPrincipalScheduleSummary(){
  const el = document.getElementById('principalScheduleSummary');
  if(!el) return;

  const sched = _mm_getPrincipalScheduleStore();
  const keys = _mm_monthKeysNext12();
  const any = keys.some(k => (parseFloat(sched[k])||0) > 0);

  if(any){
    const first = keys[0];
    const v = Math.max(0, parseFloat(sched[first])||0);
    el.textContent = `Custom schedule (next month: ${money(v)})`;
  }else{
    // fallback to numeric extraMonthly if still present
    const v = (Array.isArray(debtPlan.extraMonthly) ? 0 : ((Array.isArray(debtPlan.extraMonthly)?debtPlan.extraMonthly:(parseFloat(debtPlan.extraMonthly)||0))));
    el.textContent = v > 0 ? `Fixed: ${money(v)} / month` : 'Set monthly principal payments';
  }
}

function renderPrincipalScheduleTable(){
  const body = document.getElementById('principalScheduleBody');
  const hint = document.getElementById('principalScheduleHint');
  if(!body) return;

  const sched = _mm_getPrincipalScheduleStore();
  const keys = _mm_monthKeysNext12();

  const hasFc = (typeof hasForecast === 'function') ? hasForecast() : true;
  if(hint){
    hint.textContent = hasFc
      ? 'Tip: Future months adjust automatically as you add principal payments.'
      : 'Tap “Calculate Forecast” for the most accurate plan preview.';
  }

  const payDay = clamp(parseInt((debtPlan && debtPlan.payDay) || '1', 10) || 1, 1, 28);
  const buffer = (typeof getBuffer === 'function') ? getBuffer() : Math.max(0, parseFloat(document.getElementById('debtBufferSelect')?.value||'0')||0);

  // Build an adjustable copy of daily balances so we can apply month-by-month principal payments
  const db = (typeof _mm_getDailyBalances === 'function')
    ? _mm_getDailyBalances()
    : (Array.isArray(dailyBalances) ? dailyBalances : (Array.isArray(window.dailyBalances) ? window.dailyBalances : []));

  const rows = Array.isArray(db) ? db.map(r=>{
    const d = (r.date instanceof Date) ? r.date : new Date(r.date);
    const bal = Number(r.balance);
    return { __dt: d, __bal: isFinite(bal) ? bal : 0 };
  }).filter(r=>r.__dt && !isNaN(r.__dt.getTime())) : [];

  rows.sort((a,b)=>a.__dt - b.__dt);

  function monthKeyFromDate(d){
    return _mm_monthKey(d);
  }
  function groupRowsByMonth(rowsArr){
    const out = {};
    rowsArr.forEach(r=>{
      const k = monthKeyFromDate(r.__dt);
      (out[k] ||= []).push(r);
    });
    return out;
  }
  function payDateForMonthKey(key){
    const [yy, mm] = key.split('-').map(n=>parseInt(n,10));
    const dd = Math.max(1, Math.min(28, payDay));
    return new Date(yy, (mm||1)-1, dd);
  }
  function applyPrincipalAtDate(amount, payDate){
    const amt = Math.max(0, Number(amount)||0);
    if(!amt) return;
    for(const r of rows){
      if(r.__dt >= payDate){
        r.__bal -= amt;
      }
    }
  }

  body.innerHTML = '';

  // Month-by-month: compute surplus from current adjusted balances, then apply that month's principal to future days
  for(const k of keys){
    const byMonth = groupRowsByMonth(rows);
    const days = byMonth[k] || [];

    let minAfter = 0;
    try{
      // _mm_minAfterPayDay reads day balances; provide objects with __dt/__bal
      minAfter = (typeof _mm_minAfterPayDay === 'function') ? _mm_minAfterPayDay(days, payDay) : 0;
    }catch(e){ minAfter = 0; }

    const surplus = Math.max(0, minAfter - buffer);

    const planned = Math.max(0, parseFloat(sched[k])||0);

    const tr = document.createElement('tr');
    tr.className = 'border-t';
    tr.innerHTML = `
      <td class="p-2 text-left">${_mm_monthLabelFromKey(k)}</td>
<td class="p-2 text-right">
        <input type="number" min="0" step="1"
               class="w-28 p-1 border rounded text-right"
               value="${planned}"
               oninput="updatePrincipalScheduleValue('${k}', this.value)">
      </td>
    `;
    body.appendChild(tr);

    // Apply this month's planned principal to all future days (starting on pay day of this month)
    const payDate = payDateForMonthKey(k);
    applyPrincipalAtDate(planned, payDate);
  }

  renderPrincipalScheduleSummary();
}

function updatePrincipalScheduleValue(monthKey, val){
  const sched = _mm_getPrincipalScheduleStore();
  const n = Math.max(0, parseFloat(val)||0);
  sched[monthKey] = isFinite(n) ? n : 0;
  try{ 
  // If linked to a credit card account, the debt current balance mirrors the account current balance
  try{
    if(currentDebt && currentDebt.linkedCreditAccountId){
      const acc = (accounts||[]).find(a=>a && a.id===currentDebt.linkedCreditAccountId);
      if(acc){
        currentDebt.currentBalance = parseFloat(acc.currentBalance||'0')||0;
      }
    }
  }catch(e){}
saveData(); }catch(e){}
  renderPrincipalScheduleSummary();

  // Re-render table so future-month surplus reflects this change immediately
  clearTimeout(window.__mm_principalScheduleRerenderT);
  window.__mm_principalScheduleRerenderT = setTimeout(()=>{
    try{ renderPrincipalScheduleTable(); }catch(e){}
  }, 50);
}

function applyPrincipalScheduleToForecast(){
  const keys = _mm_monthKeysNext12();
  const sched = _mm_getPrincipalScheduleStore();

  // Build an array for simulatePayoff: monthIndex -> extra principal
  const extras = keys.map(k => Math.max(0, parseFloat(sched[k])||0));

  debtPlan.extraMonthly = extras;
  debtPlan.extraMonthlyMode = 'custom';
  if(typeof debtPlan.applyToForecast !== 'boolean') debtPlan.applyToForecast = true;

  // Reflect toggle in UI
  const applyEl = document.getElementById('applyPlanToForecast');
  if(applyEl) applyEl.checked = true;

  try{ saveData(); }catch(e){}
  try{ if(typeof computeForecast === 'function') computeForecast(); }catch(e){}
  try{ renderDebtPlanner(); }catch(e){}
  try{ if(typeof refreshSafeExtraUI === 'function') refreshSafeExtraUI(); }catch(e){}

  closePrincipalScheduleModal();
}


// ---------- Debt Plan Month Modal ----------
function renderDebtPlanMonthPicker(selectedOffset){
  const picker = document.getElementById('dpMonthPicker');
  if(!picker) return;

  const base = lastDebtSimBaseMonth || new Date(new Date().getFullYear(), new Date().getMonth(), 1);
  picker.innerHTML = '';

  const maxMonths = Math.min(12, (lastDebtSim?.schedule?.length || 0));
  for(let i=0; i<maxMonths; i++){
    const d = new Date(base.getFullYear(), base.getMonth()+i, 1);
    const label = d.toLocaleDateString(undefined,{month:'short', year:'2-digit'});

    const btn = document.createElement('button');
    btn.className =
      'px-3 py-2 rounded-full border text-sm whitespace-nowrap ' +
      (i === selectedOffset ? 'bg-blue-600 text-white border-blue-600' : 'bg-white text-gray-700');

    btn.textContent = label;
    btn.onclick = ()=>openDebtPlanMonthModal(i);
    picker.appendChild(btn);
  }
}

function openDebtPlanMonthModal(monthOffset){
  if(!lastDebtSim || !lastDebtSim.schedule) return;

  const base = lastDebtSimBaseMonth || new Date(new Date().getFullYear(), new Date().getMonth(), 1);
  const titleDate = new Date(base.getFullYear(), base.getMonth()+monthOffset, 1);

  const row = lastDebtSim.schedule[monthOffset];
  if(!row){
    alert('No plan data for that month yet.');
    return;
  }

  currentDebtPlanMonthOffset = monthOffset;
  renderDebtPlanMonthPicker(monthOffset);

  const payments = row.payments || {};
  const interest = row.interest || {};
  const balances = row.balances || {};

  const totalPayment = Object.values(payments).reduce((s,x)=>s+(parseFloat(x)||0),0);
  const interestAdded = Object.values(interest).reduce((s,x)=>s+(parseFloat(x)||0),0);
  const remainingTotal = Object.values(balances).reduce((s,x)=>s+(Math.max(0, parseFloat(x)||0)),0);

  document.getElementById('debtPlanMonthTitle').textContent =
    titleDate.toLocaleDateString(undefined,{month:'long', year:'numeric'}) + ' • Debt Plan';

  document.getElementById('dpTotalPayment').textContent = money(totalPayment);
  document.getElementById('dpInterestAdded').textContent = money(interestAdded);
  document.getElementById('dpRemainingTotal').textContent = money(remainingTotal);

  const payList = document.getElementById('dpPaymentsList');
  const balList = document.getElementById('dpBalancesList');
  payList.innerHTML = '';
  balList.innerHTML = '';

  Object.entries(payments)
    .map(([id, amt])=>({id, amt: parseFloat(amt)||0, name:(debts.find(d=>d.id===id)||{}).name || 'Debt'}))
    .filter(x=>x.amt>0)
    .sort((a,b)=>b.amt-a.amt)
    .forEach(x=>{
      const li = document.createElement('li');
      li.className='text-gray-800';
      li.textContent = `${x.name}: ${money(x.amt)}`;
      payList.appendChild(li);
    });

  if(!payList.children.length){
    const li = document.createElement('li');
    li.className='text-gray-500';
    li.textContent='No payments this month.';
    payList.appendChild(li);
  }

  Object.entries(balances)
    .map(([id, bal])=>({id, bal: Math.max(0, parseFloat(bal)||0), name:(debts.find(d=>d.id===id)||{}).name || 'Debt'}))
    .sort((a,b)=>b.bal-a.bal)
    .forEach(x=>{
      const li = document.createElement('li');
      li.className='text-gray-800';
      li.textContent = `${x.name}: ${money(x.bal)}`;
      balList.appendChild(li);
    });

  document.getElementById('debtPlanMonthModal').classList.remove('hidden');
}
function closeDebtPlanMonthModal(){ document.getElementById('debtPlanMonthModal').classList.add('hidden'); }

function dpPrevMonth(){
  const prev = Math.max(0, (currentDebtPlanMonthOffset||0)-1);
  openDebtPlanMonthModal(prev);
}
function dpNextMonth(){
  const max = Math.min(11, (lastDebtSim?.schedule?.length || 1)-1);
  const next = Math.min(max, (currentDebtPlanMonthOffset||0)+1);
  openDebtPlanMonthModal(next);
}

// ---------- Debt Planner Render ----------
function applyDebtPlanSettings(){
  // Apply Pay Day (principal schedule is set separately)
  const payDayEl = document.getElementById('debtPlanPayDay');
  const btn = document.getElementById('applyDebtPlanSettingsBtn');
  const rawPayDay = parseInt(payDayEl?.value || '', 10);
  const payDay = clamp(isNaN(rawPayDay) ? (debtPlan.payDay || 1) : rawPayDay, 1, 28);
  if(payDayEl) payDayEl.value = String(payDay);

  // Persist per-profile
  debtPlan.payDay = payDay;
  saveData();

  // UI feedback
  if(btn){
    const prev = btn.textContent;
    btn.textContent = 'Applied ✓';
    btn.disabled = true;
    btn.classList.add('opacity-80');
    btn.classList.remove('ring-2','ring-blue-300');
    setTimeout(()=>{
      btn.textContent = prev;
      btn.disabled = false;
      btn.classList.remove('opacity-80');
    }, 900);
  }

  // Re-render planner + refresh any derived UI
  renderDebtPlanner();
  if(typeof refreshSafeExtraUI === 'function') refreshSafeExtraUI();

  // If the plan is applied to forecast, recalc forecast so the change is reflected immediately.
  if(debtPlan.applyToForecast){
    try { if(typeof computeForecast === 'function') computeForecast(); }
    catch(e){}
  }
}

function renderDebtPlanner(){
  const _mm_pid = (typeof getActiveProfileId==='function') ? getActiveProfileId() : '';
  const list = document.getElementById('debtList');
  const empty = document.getElementById('debtEmptyState');
  if(!list) return;

  // Restore apply toggle from saved state (first render only)
  const applyElInit = document.getElementById('applyPlanToForecast');
  if(applyElInit && applyElInit.dataset.profileId !== _mm_pid){
    applyElInit.checked = !!debtPlan.applyToForecast;
    applyElInit.dataset.profileId = _mm_pid;
  }
  // Initialize inputs from saved state (first render only) so we don't overwrite saved values.
  const sweepElInit = document.getElementById('sweepModeToggle');
  if(sweepElInit && sweepElInit.dataset.profileId !== _mm_pid){
    sweepElInit.checked = !!debtPlan.sweepMode;
    sweepElInit.dataset.profileId = _mm_pid;
  }
  const payDayElInit = document.getElementById('debtPlanPayDay');
  if(payDayElInit && payDayElInit.dataset.profileId !== _mm_pid){
    payDayElInit.value = (debtPlan.payDay ?? 1);
    payDayElInit.dataset.profileId = _mm_pid;

  // Restore buffer (per Project/profile) on first render so it persists across profile switches
  const bufferSelInit = document.getElementById('debtBufferSelect');
  if(bufferSelInit && bufferSelInit.dataset.profileId !== _mm_pid){
    const savedBuf = (debtPlan && typeof debtPlan.sweepBuffer !== 'undefined') ? debtPlan.sweepBuffer : 500;
    bufferSelInit.value = String(savedBuf ?? 500);
    bufferSelInit.dataset.profileId = _mm_pid;
  }

  }

  // Read controls
  const strategy = getStrategy();
    const applyEl = document.getElementById('applyPlanToForecast');
  const payDayEl = document.getElementById('debtPlanPayDay');

  const sweepEl = document.getElementById('sweepModeToggle');
  const sweepMode = !!sweepEl?.checked;
  const bufferSel = document.getElementById('debtBufferSelect');
  const sweepBuffer = clamp(parseFloat(bufferSel?.value || (debtPlan.sweepBuffer ?? 500) || 0) || 0, 0, 1000000);
  // IMPORTANT: extra/payDay are only applied when the user taps the Apply button.
  // Planner calculations should use the persisted (per-profile) values, not the in-progress edits.
  const extra = Array.isArray(debtPlan.extraMonthly) ? debtPlan.extraMonthly : (parseFloat(debtPlan.extraMonthly || '0') || 0);
  const extraEl = document.getElementById('extraMonthlyPayment');

  if(extraEl){
    extraEl.disabled = sweepMode;
    extraEl.classList.toggle('opacity-60', sweepMode);
  }

  const apply = !!applyEl?.checked;

  const payDay = clamp(parseInt(debtPlan.payDay || 1, 10) || 1, 1, 28);

  // Persist only settings that should update immediately
  debtPlan.strategy = strategy;
  // debtPlan.extraMonthly + debtPlan.payDay are applied via applyDebtPlanSettings()
  // debtPlan.applyToForecast is persisted via onApplyPlanToggleChange()
  // debtPlan.sweepMode is persisted via onSweepModeToggleChange()
  debtPlan.sweepBuffer = sweepBuffer;
  saveData();

  // List
  list.innerHTML = '';
  if(debts.length===0){
    empty?.classList.remove('hidden');
  } else {
    empty?.classList.add('hidden');

    const sorted = [...debts].sort((a,b)=>{
      if(strategy === 'snowball') return (a.balance||0) - (b.balance||0);
      if(strategy === 'avalanche') return (b.apr||0) - (a.apr||0);
      return (a.order||0) - (b.order||0);
    });

    sorted.forEach(d=>{
      const row = document.createElement('div');
      row.className='p-3 border rounded-lg bg-gray-50 cursor-pointer';
      row.onclick=()=>openDebtPlanPreviewModal(d.id);

      row.innerHTML = `
        <div class="flex items-start justify-between gap-3">
          <div>
            <div class="font-semibold">${d.name || 'Debt'}</div>
            <div class="text-xs text-gray-500">
              ${d.type === 'loan' ? 'Loan' : 'Credit Card'} • APR: ${(parseFloat(d.apr)||0).toFixed(2)}% • Min: ${money(d.minPayment||0)}
            </div>
          </div>
          <div class="text-right flex flex-col items-end gap-2">
            <div>
              <div class="text-sm text-gray-500">Balance</div>
              <div class="font-bold">${money(d.balance||0)}</div>
            </div>
            <button class="text-xs px-3 py-1 border rounded" onclick="event.stopPropagation(); openDebtModal('${d.id}')">Edit</button>
          </div>
        </div>
      `;
list.appendChild(row);
    });
  }

  // Simulate
  let sim;
  if(debtPlan.sweepMode){
    // IMPORTANT: Sweep should be computed from a stable *baseline* forecast (without injected debt-plan payments),
    // otherwise the plan oscillates when you re-render or switch tabs.
    try{
      // Remove any previously injected plan payments before building baseline rows
      removeGeneratedDebtExpenses();
      // Build baseline forecast rows (no plan payments)
      computeForecast();
      window._mm_baselineRows = (Array.isArray(dailyBalances) ? dailyBalances.map(r=>({ ...r, date: new Date(r.date) })) : []);
    }catch(e){}
    const extras = computeSweepExtrasFromForecast(debtPlan.sweepBuffer ?? 0, 24); // up to 24 months
    debtPlan._sweepExtras = extras;
    sim = simulatePayoff(debts, strategy, extras);
  } else {
    sim = simulatePayoff(debts, strategy, extra);
  }
  lastDebtSim = sim;
  const now = new Date();
  lastDebtSimBaseMonth = new Date(now.getFullYear(), now.getMonth(), 1);

  const debtFreeEl = document.getElementById('debtFreeDate');
  const interestEl = document.getElementById('totalInterest');
  const monthsEl = document.getElementById('monthsToPayoff');

  const summary = _mm_computeDebtPlannerSummaryStats();

  if(!summary.ok){
    debtFreeEl.textContent='';
    interestEl.textContent='';
    monthsEl.textContent='';
  } else {
    debtFreeEl.textContent = summary.debtFreeDate ? summary.debtFreeDate.toLocaleDateString(undefined,{month:'long', year:'numeric'}) : '';
    interestEl.textContent = (typeof summary.totalInterest === 'number') ? money(summary.totalInterest) : '';
    monthsEl.textContent = (typeof summary.months === 'number') ? `${summary.months}` : '';
  }

  // Custom order UI
  renderCustomOrder();

  // Apply plan to forecast
  removeGeneratedDebtExpenses();
  if(debtPlan.applyToForecast && debts.length>0){
    injectDebtPlanExpenses(sim);
  }

  // Persist & refresh forecast/warnings
  saveDebtsToStorage();
  saveDebtPlan();
  saveData();
  computeForecast();
  updateDebtWarnings();
  try{ renderSafeExtraByMonth(); }catch(e){}
}

// ---------- Balance Input Listener ----------
document.getElementById('balance').addEventListener('input', e=>{
  currentBalance=parseFloat(e.target.value)||0;
  saveData();
  renderDashboard();
});

// ---------- Initialize ----------
window.addEventListener('DOMContentLoaded', ()=>{
  ensureProfilesMigration();
  autoRecoverIfBlank();
  loadProfileSelectUI();
  loadData();
  // Ensure forecast reflects the stored Apply toggle state
  try{ computeForecast(); }catch(e){}
  renderDashboard();
  renderAccounts();
  renderBillsPage();
  setupDayModalSwipe();
// Restore Debt Planner controls
  setTimeout(()=>{
    const strat = debtPlan.strategy || 'avalanche';
    const radio = document.querySelector(`input[name="debtStrategy"][value="${strat}"]`);
    if(radio) radio.checked = true;

    const extraEl = document.getElementById('extraMonthlyPayment');

        if(extraEl){
        const v = debtPlan.extraMonthly;
        extraEl.value = Array.isArray(v) ? 0 : (v || 0);
    }

    const applyEl = document.getElementById('applyPlanToForecast');
    if(applyEl) applyEl.checked = !!debtPlan.applyToForecast;


    // Main-page toggle mirrors the Debt Planner toggle
    const applyMainEl = document.getElementById('applyDebtPlanToggle');
    if(applyMainEl) applyMainEl.checked = !!debtPlan.applyToForecast;

    const payDayEl = document.getElementById('debtPlanPayDay');
    if(payDayEl) payDayEl.value = debtPlan.payDay || 1;
  }, 0);

  // Mark payment settings as "dirty" (requires Apply button)
  const markDebtPlanSettingsDirty = ()=>{
    const btn = document.getElementById('applyDebtPlanSettingsBtn');
    if(!btn) return;
    btn.classList.add('ring-2','ring-blue-300');
  };
  const dpExtraEl = document.getElementById('extraMonthlyPayment');
  if(dpExtraEl){
    dpExtraEl.addEventListener('input', markDebtPlanSettingsDirty);
    dpExtraEl.addEventListener('change', markDebtPlanSettingsDirty);
  }
  const dpPayDayEl2 = document.getElementById('debtPlanPayDay');
  if(dpPayDayEl2){
    dpPayDayEl2.addEventListener('input', markDebtPlanSettingsDirty);
    dpPayDayEl2.addEventListener('change', markDebtPlanSettingsDirty);
  }
  const dpApplyEl2 = document.getElementById('applyPlanToForecast');
  if(dpApplyEl2){
    dpApplyEl2.addEventListener('change', ()=>{
      // Persist + apply immediately
      onApplyPlanToggleChange(!!dpApplyEl2.checked);
      // Keep the main-page toggle in sync
      const applyMainEl = document.getElementById('applyDebtPlanToggle');
      if(applyMainEl) applyMainEl.checked = !!dpApplyEl2.checked;
      renderDebtPlanner();
    });
  }

  // Main-page toggle (above mini-strip) — keep in sync + persist
  const dpApplyMain = document.getElementById('applyDebtPlanToggle');
  if(dpApplyMain){
    dpApplyMain.addEventListener('change', ()=>{
      onApplyPlanToggleChange(!!dpApplyMain.checked);
      const applyEl = document.getElementById('applyPlanToForecast');
      if(applyEl) applyEl.checked = !!dpApplyMain.checked;
      renderDebtPlanner();
    });
  }
  document.querySelectorAll('input[name="debtStrategy"]').forEach(r=>{
    r.addEventListener('change', ()=>{ renderDebtPlanner(); });
  });

  renderDebtPlanner();
});

/* ===== Robust Safe Extra (fixes missing window.applySafeExtra + $0 due to scope/timing) ===== */
(function(){
  function getDailyBalances(){
    try { if (typeof dailyBalances !== 'undefined' && dailyBalances) return dailyBalances; } catch(e){}
    return window.dailyBalances || {};
  }
  function getMultiMonthData(){
    try { if (typeof multiMonthData !== 'undefined' && Array.isArray(multiMonthData)) return multiMonthData; } catch(e){}
    return window.multiMonthData || [];
  }

  function hasForecast(){
    const db = getDailyBalances();
    const mm = getMultiMonthData();
    return mm && mm.length > 0 && db && Object.keys(db).length > 0;
  }

  function fmt(n){
    if (typeof formatCurrency === 'function') return formatCurrency(n);
    try { return '$' + (Math.round(n*100)/100).toFixed(2); } catch(e){ return '$0.00'; }
  }

  function getBuffer(){
    const sel = document.getElementById('debtBufferSelect');
    const v = sel ? parseFloat(sel.value || '0') : 0;
    return isFinite(v) ? v : 0;
  }

  function getAvgMonthlySurplus(){
    const mm = getMultiMonthData();
    if (!mm.length) return 0;
    const total = mm.reduce((a,m)=>a + ((m.income||0) - (m.bills||0)), 0);
    return total / mm.length;
  }

  function getLowestBalance(){
    const db = getDailyBalances();
    const vals = Object.values(db).map(v => +v).filter(v => isFinite(v));
    return vals.length ? Math.min(...vals) : 0;
  }

  function getMonthlyLowestBalances(limit=12){
    const db = getDailyBalances();
    const byMonth = [];
    const map = new Map(); // key -> lowest
    for (const [k,vRaw] of Object.entries(db)){
      const v = +vRaw;
      if (!isFinite(v)) continue;
      const d = new Date(k);
      if (isNaN(d.getTime())) continue;
      const key = d.getFullYear() + '-' + d.getMonth();
      if (!map.has(key)) map.set(key, v);
      else map.set(key, Math.min(map.get(key), v));
    }
    // keep insertion order (which follows object iteration order in most modern engines, but we sort just in case)
    const sorted = Array.from(map.entries()).sort((a,b)=>{
      const [ay,am]=a[0].split('-').map(Number);
      const [by,bm]=b[0].split('-').map(Number);
      return (ay-by) || (am-bm);
    });
    return sorted.slice(0, limit).map(x=>x[1]);
  }

  function calculateSafeExtra(){
    if (!hasForecast()) return 0;
    const buffer = getBuffer();
    const avgSurplus = getAvgMonthlySurplus();

    const sweepOn = !!document.getElementById('sweepModeToggle')?.checked;

    if (sweepOn){
      const lows = getMonthlyLowestBalances(12);
      if (!lows.length) return 0;
      const sweeps = lows.map(low => Math.max(0, low - buffer));
      const avgSweep = sweeps.reduce((a,b)=>a+b,0) / sweeps.length;
      return Math.max(0, Math.min(avgSurplus, avgSweep));
    }

    const lowest = getLowestBalance();
    // Safe extra is limited by both: monthly surplus AND headroom above buffer at the worst point.
    return Math.max(0, Math.min(avgSurplus, lowest - buffer));
  }

  function refreshUI(){
    const valueEl = document.getElementById('safeExtraValue');
    const breakdownEl = document.getElementById('safeExtraBreakdown');
    if (!valueEl || !breakdownEl) return;

    if (!hasForecast()){
      valueEl.textContent = '$0.00';
      breakdownEl.innerHTML = `<span class="text-gray-500">Run <b>Calculate Forecast</b> to compute your safe extra.</span>`;
      return;
    }

    const buffer = getBuffer();
    const avgSurplus = getAvgMonthlySurplus();
    const lowest = getLowestBalance();
    const safe = calculateSafeExtra();

    valueEl.textContent = fmt(safe);

    const sweepOn = !!document.getElementById('sweepModeToggle')?.checked;
    const modeLine = sweepOn ? `Mode: <b>Sweep</b> (varies monthly)` : `Mode: <b>Fixed</b>`;

    breakdownEl.innerHTML = `
      ${modeLine}<br>
      Avg monthly surplus: <b>${fmt(avgSurplus)}</b><br>
      Lowest forecasted balance: <b>${fmt(lowest)}</b><br>
      Buffer: <b>${fmt(buffer)}</b>
    `;
  }

  // Expose button handler
  window.applySafeExtra = function(){
    const input = document.getElementById('extraMonthlyPayment');
    if (!input) return;
    const val = calculateSafeExtra();
    input.value = (isFinite(val) ? val : 0).toFixed(2);
    input.dispatchEvent(new Event('input', { bubbles:true }));
    // Often the planner recomputes after input; refresh after a tick
    setTimeout(refreshUI, 50);
  };

  // Refresh on common triggers
  document.addEventListener('change', (e)=>{
    if (e.target?.id === 'debtBufferSelect' || e.target?.id === 'sweepModeToggle') {
      setTimeout(refreshUI, 0);
    }
  });
  document.addEventListener('input', (e)=>{
    if (e.target?.id === 'extraMonthlyPayment') {
      setTimeout(refreshUI, 0);
    }
  });

  // Hook calculateForecast so safe extra updates whenever forecast updates
  (function(){
    const orig = window.calculateForecast;
    if (typeof orig !== 'function' || orig._mm_safeextra_wrapped) return;
    const wrapped = function(){
      const res = orig.apply(this, arguments);
      setTimeout(refreshUI, 60);
      return res;
    };
    wrapped._mm_safeextra_wrapped = true;
    window.calculateForecast = wrapped;
  })();

  // Hook showTab so it refreshes when you open Debt Planner
  (function(){
    const orig = window.showTab;
    if (typeof orig !== 'function' || orig._mm_safeextra_wrapped) return;
    const wrapped = function(tab){
      const res = orig.apply(this, arguments);
      if (tab === 'debtPlanner') setTimeout(refreshUI, 60);
      return res;
    };
    wrapped._mm_safeextra_wrapped = true;
    window.showTab = wrapped;
  })();

  // First refresh
  setTimeout(refreshUI, 200);
})();

/* ===== Safe Extra V4 (correct for dailyBalances ARRAY) + mini strip + pay-day hint ===== */
(function(){
  // ----- data accessors (work with top-level let) -----
  function getDailyRows(){
    try { if (typeof dailyBalances !== 'undefined' && Array.isArray(dailyBalances)) return dailyBalances; } catch(e){}
    return Array.isArray(window.dailyBalances) ? window.dailyBalances : [];
  }
  function getMultiMonths(){
    try { if (typeof multiMonthData !== 'undefined' && Array.isArray(multiMonthData)) return multiMonthData; } catch(e){}
    return Array.isArray(window.multiMonthData) ? window.multiMonthData : [];
  }
  function hasForecast(){
    const dr = getDailyRows();
    const mm = getMultiMonths();
    return dr.length > 0 && mm.length > 0;
  }
  function fmt(n){
    if (typeof formatCurrency === 'function') return formatCurrency(n);
    return '$' + (Math.round((+n||0)*100)/100).toFixed(2);
  }
  function getBuffer(){
    const sel = document.getElementById('debtBufferSelect');
    const v = sel ? parseFloat(sel.value || '0') : 0;
    return isFinite(v) ? v : 0;
  }
  function getPayDay(){
    // IMPORTANT: use the persisted (per-profile) value, not in-progress edits.
    const v = parseInt((debtPlan && debtPlan.payDay) || '1', 10);
    return Math.min(28, Math.max(1, isFinite(v) ? v : 1));
  }
  function getAvgMonthlySurplus(){
    const mm = getMultiMonths();
    if (!mm.length) return 0;
    return mm.reduce((a,m)=>a+((+m.income||0)-(+m.bills||0)),0) / mm.length;
  }
  function rowDate(r){
    const d = r?.date;
    if (d instanceof Date) return d;
    const nd = new Date(d);
    return isNaN(nd.getTime()) ? null : nd;
  }
  function getLowestBalance(){
    const dr = getDailyRows();
    let low = Infinity;
    for (const r of dr){
      const b = +r.balance;
      if (isFinite(b)) low = Math.min(low, b);
    }
    return low === Infinity ? 0 : low;
  }
  function getMonthlyLows(limit=12){
    const dr = getDailyRows();
    const map = new Map(); // yyyy-mm -> low
    for (const r of dr){
      const d = rowDate(r);
      if (!d) continue;
      const key = d.getFullYear() + '-' + String(d.getMonth()+1).padStart(2,'0');
      const b = +r.balance;
      if (!isFinite(b)) continue;
      if (!map.has(key)) map.set(key, b);
      else map.set(key, Math.min(map.get(key), b));
    }
    const sorted = Array.from(map.entries()).sort((a,b)=>a[0].localeCompare(b[0]));
    return sorted.slice(0, limit).map(([k,v])=>({key:k, low:v}));
  }

  function calculateSafeExtra(){
    if (!hasForecast()) return 0;
    const buffer = getBuffer();
    const avgSurplus = getAvgMonthlySurplus();
    const sweepOn = !!document.getElementById('sweepModeToggle')?.checked;

    if (sweepOn){
      const lows = getMonthlyLows(12).map(x=>x.low);
      if (!lows.length) return 0;
      const sweeps = lows.map(low => Math.max(0, low - buffer));
      const avgSweep = sweeps.reduce((a,b)=>a+b,0) / sweeps.length;
      return Math.max(0, Math.min(avgSurplus, avgSweep));
    }

    const lowest = getLowestBalance();
    return Math.max(0, Math.min(avgSurplus, lowest - buffer));
  }

  // ----- UI helpers -----
  function renderMiniStrip(){
    const strip = document.getElementById('miniBalanceStrip');
    if (!strip) return;
    strip.innerHTML = '';
    if (!hasForecast()) return;

    const buffer = getBuffer();
    const lows = getMonthlyLows(60);
    if (!lows.length) return;

    const values = lows.map(x=>x.low);
    const vMin = Math.min(...values);
    const vMax = Math.max(...values);
    const denom = (vMax - vMin) || 1;

    function monthLabel(key){
      // key is YYYY-MM
      const parts = String(key||'').split('-');
      const y = parts[0] || '';
      const mm = parseInt(parts[1]||'1', 10);
      const d = new Date(parseInt(y||'2000',10), Math.max(0,(mm||1)-1), 1);
      const mon = d.toLocaleString('default', { month: 'short' });
      return { mon, y };
    }

    // Ensure strip uses column layout (in case Tailwind classes changed elsewhere)
    strip.classList.add('overflow-visible');
    strip.style.display = 'flex';
    strip.style.alignItems = 'flex-end';
    strip.style.gap = '4px';
    strip.style.minHeight = '72px';
    strip.style.paddingBottom = '4px';
    strip.style.maxWidth = '100%';

    lows.forEach((mo, idx)=>{
      const col = document.createElement('div');
      col.style.width = '18px'; // ~ w-6
      col.style.display = 'flex';
      col.style.flexDirection = 'column';
      col.style.alignItems = 'center';

      const stack = document.createElement('div');
      stack.style.position = 'relative';
      stack.style.width = '16px'; // ~ w-4
      stack.style.height = '44px';
      stack.style.display = 'flex';
      stack.style.flexDirection = 'column';
      stack.style.justifyContent = 'flex-end';

      const bar = document.createElement('div');
      const pct = ((mo.low - vMin)/denom)*100;
      bar.style.height = (Math.max(8, pct)) + '%';
      const under = mo.low < buffer;
      bar.className = under ? 'bg-red-500' : 'bg-green-500';
      bar.style.width = '12px';
      bar.style.borderRadius = '3px';
      bar.title = `${mo.key}: ${fmt(mo.low)}`;

      stack.appendChild(bar);

      const lbl = document.createElement('div');
      lbl.className = 'text-[9px] text-gray-500 mt-1 text-center leading-tight';
      const { mon, y } = monthLabel(mo.key);
      const showYear = (String(mo.key||'').endsWith('-01')) || (idx === 0);
      lbl.innerHTML = showYear ? `${mon}<br><span class="opacity-70">${y}</span>` : `${mon}<br><span class="opacity-70">&nbsp;</span>`;

      col.appendChild(stack);
      col.appendChild(lbl);
      strip.appendChild(col);
    });
  }

function _mm_monthKey(d){
  const y = d.getFullYear();
  const m = d.getMonth()+1;
  return `${y}-${String(m).padStart(2,'0')}`;
}
function _mm_monthLabel(d){
  return d.toLocaleString(undefined, {month:'short', year:'numeric'});
}

function _mm_groupDailyBalancesByMonth(){
  const db = (typeof _mm_getDailyBalances === 'function')
    ? _mm_getDailyBalances()
    : (Array.isArray(dailyBalances) ? dailyBalances : (Array.isArray(window.dailyBalances) ? window.dailyBalances : []));
  if(!Array.isArray(db) || !db.length) return {};
  const by = {};
  db.forEach(o=>{
    if(!o || !o.date) return;
    const dt = (o.date instanceof Date) ? o.date : new Date(o.date);
    if(isNaN(dt.getTime())) return;
    const k = _mm_monthKey(dt);
    (by[k] ||= []).push({ ...o, __dt: dt });
  });
  Object.keys(by).forEach(k => by[k].sort((a,b)=>a.__dt-b.__dt));
  return by;
}

// Lowest balance on/after pay day within a month
function _mm_minAfterPayDay(days, payDay){
  if(!days || !days.length) return 0;
  let minAfter = Infinity;
  days.forEach(o=>{
    const d = o.__dt.getDate();
    if(d >= payDay){
      const bal = Number(o.balance);
      if(Number.isFinite(bal)) minAfter = Math.min(minAfter, bal);
    }
  });
  if(!Number.isFinite(minAfter)){
    // If forecast doesn't include any day >= payDay (edge case), fallback to month min
    minAfter = Infinity;
    days.forEach(o=>{
      const bal = Number(o.balance);
      if(Number.isFinite(bal)) minAfter = Math.min(minAfter, bal);
    });
    if(!Number.isFinite(minAfter)) minAfter = 0;
  }
  return minAfter;
}

function renderSafeExtraByMonth(){
  const body = document.getElementById('safeExtraMonthlyBody');
  if(!body) return;

  const db = (typeof _mm_getDailyBalances === 'function')
    ? _mm_getDailyBalances()
    : (Array.isArray(dailyBalances) ? dailyBalances : (Array.isArray(window.dailyBalances) ? window.dailyBalances : []));

  if(!Array.isArray(db) || !db.length){
    body.innerHTML = '<tr><td class="p-2 text-gray-500" colspan="4">Tap <b>Calculate Forecast</b> to compute monthly safe extra.</td></tr>';
    return;
  }

  try{
    const byMonth = _mm_groupDailyBalancesByMonth();
    const keys = Object.keys(byMonth).sort();
    if(!keys.length){
      body.innerHTML = '<tr><td class="p-2 text-gray-500" colspan="4">No forecast data available.</td></tr>';
      return;
    }

    const bufferSel = document.getElementById('debtBufferSelect');
    const buffer = Math.max(0, parseFloat(bufferSel?.value || '0') || 0);

    const payDay = clamp(parseInt((debtPlan && debtPlan.payDay) || '1', 10) || 1, 1, 28);

    const first = byMonth[keys[0]][0].__dt;
    const start = new Date(first.getFullYear(), first.getMonth(), 1);

    body.innerHTML = '';
    for(let i=0; i<60; i++){
      const d = new Date(start.getFullYear(), start.getMonth()+i, 1);
      const k = _mm_monthKey(d);
      const days = byMonth[k] || [];

      const minAfter = _mm_minAfterPayDay(days, payDay);
      const safe = Math.max(0, minAfter - buffer);

      const safeClass = safe > 0 ? 'text-green-700' : 'text-gray-500';
      const minClass = minAfter >= 0 ? 'text-gray-700' : 'text-red-600';

      const tr = document.createElement('tr');
      tr.className = 'border-t';
      tr.innerHTML = `
        <td class="p-2 text-left">${_mm_monthLabel(d)}</td>
        <td class="p-2 text-right ${minClass}">${money(minAfter)}</td>
        <td class="p-2 text-right">${money(buffer)}</td>
        <td class="p-2 text-right ${safeClass}">${money(safe)}</td>
      `;
      body.appendChild(tr);
    }
  }catch(e){
    body.innerHTML = '<tr><td class="p-2 text-red-600" colspan="4">Could not render monthly safe extra (please refresh forecast).</td></tr>';
  }
}

function renderPayDayHint(){
  const el = document.getElementById('paymentDayImpact');
  if (!el) return;
  try{
    // If forecast isn't ready yet, clear hint and exit
    if (typeof hasForecast === 'function' && !hasForecast()){
      el.innerHTML = '';
      return;
    }

    // If there is an existing helper for the hint, use it; otherwise keep minimal.
    if (typeof getPayDayImpact === 'function'){
      el.innerHTML = getPayDayImpact() || '';
      return;
    }

    // Fallback: compute a simple hint if we can, otherwise leave blank
    el.innerHTML = el.innerHTML || '';
  }catch(e){
    el.innerHTML = '';
  }
}


function refreshSafeExtraUI(){
    const valueEl = document.getElementById('safeExtraValue');
    const breakdownEl = document.getElementById('safeExtraBreakdown');
    if (!valueEl || !breakdownEl) return;

    if (!hasForecast()){
      valueEl.textContent = '$0.00';
      breakdownEl.innerHTML = `<span class="text-gray-500">Tap <b>Calculate Forecast</b> to compute your safe principal payment.</span>`;
      renderMiniStrip();
      renderPayDayHint();
      return;
    }

    const sweepOn = !!document.getElementById('sweepModeToggle')?.checked;
    const buffer = getBuffer();

    // Next-month safe principal payment = (min balance after pay day for next month) - buffer, floored at 0
    let minAfterNext = 0;
    let safe = 0;
    try{
      const byMonth = _mm_groupDailyBalancesByMonth();
      const keys = Object.keys(byMonth||{}).sort();
      if(keys.length){
        const firstDt = (byMonth[keys[0]] && byMonth[keys[0]][0]) ? byMonth[keys[0]][0].__dt : null;
        const startMonth = firstDt ? new Date(firstDt.getFullYear(), firstDt.getMonth(), 1) : new Date();
        const k = _mm_monthKey(startMonth);
        const days = byMonth[k] || [];
        const payDay = clamp(parseInt((debtPlan && debtPlan.payDay) || '1', 10) || 1, 1, 28);
        minAfterNext = _mm_minAfterPayDay(days, payDay);
        safe = Math.max(0, minAfterNext - buffer);
      }
    }catch(e){
      minAfterNext = 0;
      safe = 0;
    }

    valueEl.textContent = fmt(safe);

    breakdownEl.innerHTML = `
      Mode: <b>${sweepOn ? 'Sweep' : 'Fixed'}</b><br>
      Next-month min after pay day: <b>${fmt(minAfterNext)}</b><br>
      Buffer: <b>${fmt(buffer)}</b>
    `;

    renderMiniStrip();
    renderPayDayHint();
  }

  // Expose action button
  window.applySafeExtra = function(){
    const input = document.getElementById('extraMonthlyPayment');
    if (!input) return;
    const val = calculateSafeExtra();
    input.value = (isFinite(val) ? val : 0).toFixed(2);
    input.dispatchEvent(new Event('input', { bubbles:true }));
    setTimeout(refreshSafeExtraUI, 80);
  };

  // Hook forecast + tab + controls
  (function(){
    const orig = window.computeForecast || window.calculateForecast;
    if (typeof orig === 'function' && !orig._mm_safeextra_wrapped){
      const wrapped = function(){
        const res = orig.apply(this, arguments);
        setTimeout(refreshSafeExtraUI, 120);
        return res;
      };
      wrapped._mm_safeextra_wrapped = true;
      if (window.computeForecast) window.computeForecast = wrapped;
      else window.calculateForecast = wrapped;
    }
  })();

  document.addEventListener('change', (e)=>{
    if (['debtBufferSelect','sweepModeToggle','debtPlanPayDay'].includes(e.target?.id)){
      setTimeout(refreshSafeExtraUI, 0);
    }
  });

  // Refresh when entering debt planner
  (function(){
    const orig = window.showTab;
    if (typeof orig === 'function' && !orig._mm_safeextra_wrapped_v4){
      const wrapped = function(tab){
        const res = orig.apply(this, arguments);
        if (tab === 'debtPlanner') setTimeout(refreshSafeExtraUI, 120);
        return res;
      };
      wrapped._mm_safeextra_wrapped_v4 = true;
      window.showTab = wrapped;
    }
  })();

  setTimeout(refreshSafeExtraUI, 250);
})();

/* ===== Sweep V5: compute "available surplus" from BASELINE forecast (no plan), month-by-month, never below buffer ===== */
(function(){
  function getForecastFn(){
    return window.computeForecast || window.calculateForecast;
  }
  function getDailyRows(){
    try { if (typeof dailyBalances !== 'undefined' && Array.isArray(dailyBalances)) return dailyBalances; } catch(e){}
    return Array.isArray(window.dailyBalances) ? window.dailyBalances : [];
  }
  function cloneRows(rows){
    return rows.map(r=>{
      const d = (r.date instanceof Date) ? new Date(r.date.getTime()) : new Date(r.date);
      return { ...r, date: d };
    });
  }
  function getPayDay(){
    const v = parseInt((debtPlan && debtPlan.payDay) || '1', 10);
    return Math.min(28, Math.max(1, isFinite(v) ? v : 1));
  }
  function getBuffer(){
    const sel = document.getElementById('debtBufferSelect');
    const v = sel ? parseFloat(sel.value || '0') : 0;
    return isFinite(v) ? v : 0;
  }

  // Build a "baseline" forecast (applyPlanToForecast OFF), capture daily rows, then restore state.
  window.mmGetBaselineDailyRows = function(){
    // Stable baseline: do NOT toggle UI / recompute forecast here (avoids sweep oscillation).
    // renderDebtPlanner() will refresh window._mm_baselineRows when needed.
    const rows = (typeof dailyBalances !== 'undefined' && Array.isArray(dailyBalances)) ? dailyBalances : (Array.isArray(window.dailyBalances)?window.dailyBalances:[]);
    return rows.map(r=>({ ...r, date: (r.date instanceof Date)? new Date(r.date) : new Date(r.date) }));
  };

  // Headroom (max safe extra) for a given month = min balance on/after payDay - buffer
  function monthKey(d){
    return d.getFullYear() + '-' + String(d.getMonth()+1).padStart(2,'0');
  }

  function computeMonthlyHeadroom(rows, buffer, payDay, months=24){
    const map = new Map(); // key -> minAfterPayDay
    for (const r of rows){
      const d = (r.date instanceof Date) ? r.date : new Date(r.date);
      if (isNaN(d.getTime())) continue;
      const bal = +r.balance;
      if (!isFinite(bal)) continue;
      const key = monthKey(d);
      if (d.getDate() < payDay) continue; // only after payment day
      if (!map.has(key)) map.set(key, bal);
      else map.set(key, Math.min(map.get(key), bal));
    }
    const sortedKeys = Array.from(map.keys()).sort((a,b)=>a.localeCompare(b)).slice(0, months);
    const headrooms = sortedKeys.map(k => Math.max(0, (map.get(k) - buffer)));
    while (headrooms.length < months) headrooms.push(0);
    return headrooms;
  }

  // Override computeSweepExtrasFromForecast to use baseline & headroom
  window.computeSweepExtrasFromForecast = function(buffer, months=24){
    const payDay = clamp(parseInt((debtPlan && debtPlan.payDay) || 1, 10), 1, 28);
    const rows = (Array.isArray(window._mm_baselineRows) && window._mm_baselineRows.length)
      ? window._mm_baselineRows
      : ((typeof dailyBalances !== 'undefined' && Array.isArray(dailyBalances)) ? dailyBalances : (Array.isArray(window.dailyBalances)?window.dailyBalances:[]));

    // monthly low after payDay -> headroom above buffer
    const map = new Map();
    for(const r of rows){
      const d = (r.date instanceof Date) ? r.date : new Date(r.date);
      if(isNaN(d.getTime())) continue;
      if(d.getDate() < payDay) continue;
      const bal = +r.balance;
      if(!isFinite(bal)) continue;
      const key = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}`;
      map.set(key, Math.min(map.get(key) ?? bal, bal));
    }
    const keys = Array.from(map.keys()).sort().slice(0, months);
    const headrooms = keys.map(k=>Math.max(0, (map.get(k) - (parseFloat(buffer)||0))));
    while(headrooms.length < months) headrooms.push(0);
    return headrooms;
  };

  // Patch Safe Extra card calculation to use baseline when in sweep mode (so it doesn't show scary negatives from injected plan)
  if (typeof window.applySafeExtra === 'function') {
    // no-op, already exposed
  }

  // Recompute/refresh Safe Extra UI after toggling applyPlanToForecast or pay day
  document.addEventListener('change', (e)=>{
    if (e.target?.id === 'applyPlanToForecast' || e.target?.id === 'debtPlanPayDay') {
      setTimeout(()=>{ if (typeof refreshSafeExtraUI === 'function') refreshSafeExtraUI(); }, 150);
    }
  });
})();

</script>
<!-- Category Manager Modal -->
<div class="fixed inset-0 bg-black bg-opacity-40 hidden items-center justify-center z-50" id="categoryModal">
<div class="bg-white rounded-2xl p-4 max-w-md w-full modal-panel">
<div class="flex items-center justify-between mb-3">
<h3 class="font-bold text-lg">Bill Categories</h3>
<button class="px-3 py-2 border rounded" onclick="closeCategoryModal()">Close</button>
</div>
<div class="flex gap-2 mb-3">
<input class="flex-1 p-2 border rounded" id="newCategoryName" placeholder="New category name"/>
<button class="px-4 py-2 bg-blue-600 text-white rounded" onclick="addCategory()">Add</button>
</div>
<div class="space-y-2" id="categoryList"></div>
<div class="text-xs text-gray-500 mt-3">“Uncategorized” is always available.</div>
</div>
</div>
<!-- Profile Modal -->
<div class="fixed inset-0 hidden items-center justify-center bg-black/60 z-50" id="profileModal">
<div class="bg-white rounded-xl shadow p-5 w-full max-w-md modal-panel">
<div class="flex items-center justify-between mb-3">
<div class="text-lg font-bold">Profiles</div>
<button class="px-3 py-2 bg-gray-200 rounded-lg" onclick="closeProfileModal()">Close</button>
</div>
<div class="space-y-3">
<div>
<div class="text-sm text-gray-600 mb-1">Active profile</div>
<div class="font-semibold" id="activeProfileName"></div>
</div>
<div class="border-t pt-3">
<div class="text-sm text-gray-600 mb-2">Create new profile</div>
<div class="flex gap-2">
<input class="border rounded-lg px-3 py-2 flex-1" id="newProfileName" placeholder="e.g., Personal, Business"/>
<button class="px-3 py-2 bg-blue-600 text-white rounded-lg" onclick="createProfile()">Create</button>
</div>
</div>
<div class="border-t pt-3">
<div class="text-sm text-gray-600 mb-2">Actions</div>
<div class="flex flex-wrap gap-2">
<button class="px-3 py-2 bg-gray-200 rounded-lg" onclick="renameActiveProfile()">Rename</button>
<button class="px-3 py-2 bg-gray-200 rounded-lg" onclick="duplicateActiveProfile()">Duplicate</button>
<button class="px-3 py-2 bg-red-600 text-white rounded-lg" onclick="deleteActiveProfile()">Delete</button>
</div>
<div class="text-xs text-gray-500 mt-2">
          Tip: Duplicate is great if you want to copy a setup for a second account.
        </div>
</div>
</div>
</div>
</div>
</body>
</html>

<script>try{ setForecastView(window._mm_forecastView || 'month'); }catch(e){}<\/script>
